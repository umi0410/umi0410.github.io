<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JPA on Jinsu Playground</title><link>https://umi0410.github.io/categories/jpa/</link><description>Recent content in JPA on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Wed, 24 Nov 2021 03:46:54 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/categories/jpa/index.xml" rel="self" type="application/rss+xml"/><item><title>쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)</title><link>https://umi0410.github.io/blog/optimizing-count-query-strategy/</link><pubDate>Wed, 24 Nov 2021 03:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/optimizing-count-query-strategy/</guid><description>시작하며 Sentry monitoring - 느려진 API Latency
짧은 영상을 바탕으로 배틀을 할 수 있는 서비스를 Spring Boot MVC + JPA로 개발하던 중 위와 같이 API Latency가 처참하게도 느린 요청들이 감지되기 시작했습니다. 그동안은 쿼리 최적화보다는 로직 개발이 더 우선시하다보니 쿼리 최적화를 미뤄왔는데, 이번 기회에 이에 대해 다뤄보려합니다. 간단하게 코드를 짜서 테스트해보느라 Go 언어를 이용했지만 JPA를 이용하든 뭘 이용하든 문제와 그에 대한 해결책의 요지는 동일할 것입니다.
아무래도 백엔드에서 API를 개발하면서 파일 데이터를 주고 받는 게 아니라면 주로 Latency가 늘어나는 이유는 다음과 같을 것입니다.</description></item></channel></rss>