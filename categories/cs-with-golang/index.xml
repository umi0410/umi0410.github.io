<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang으로 적용해보는 Computer Science on Jinsu Playground</title><link>https://umi0410.github.io/categories/cs-with-golang/</link><description>Recent content in Golang으로 적용해보는 Computer Science on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 13 Feb 2021 14:10:54 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/categories/cs-with-golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 언어로 적용해보는 Computer Science - Mutex와 Semaphore</title><link>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</link><pubDate>Wed, 20 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</guid><description>Go 언어로 적용해보는 Computer Science의 첫 번째 내용으로 OS 관련 내용 중 이론적으로는 흔하게 접할 수 있지만 실제 적용에 대한 내용은 찾아보기 힘들었던 Mutex, Semaphore에 대해 알아보려한다.
Mutex와 Semaphore은 각각의 추상적인 개념을 바탕으로 OS나 Go 등에서 사용될 수 있기에 세부적인 내용은 문맥에 따라 달라질 수 있다고 생각한다. 예를 들어 Go에서의 Mutex는 주로 sync.Mutex를 이용한 서로 다른 Goroutine의 동시 접근에 대한 제어를 의미하는 반면, 다른 프로그래밍 언어나 OS에서는 주로 서로 다른 Kernel thread나 Process에 대한 동시 접근 제어를 의미할 수 있다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Deadlock</title><link>https://umi0410.github.io/blog/golang/go-deadlock/</link><pubDate>Sun, 31 Jan 2021 18:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-deadlock/</guid><description>시작하며 개발 공부를 시작하고 여태까지 몇 년간 데드락을 실제로 접할 일은 없었다. 사실 동시성을 주의해야하는 작업을 해본 적도 없었고, 트랜잭션에 대한 개념도 없었기 때문일 수도 있다. 전공 과목에서 데드락에 대한 내용을 듣고서도 &amp;lsquo;아 이런 게 있구나&amp;rsquo; 정도로만 생각하고 넘겼었다. 하지만 Go 언어를 통해 개발을 하던 도중 Channel이나 Mutex로 인해 종종 데드락을 경험할 수 있었고, 이 경우 프로그램이 완전히 멈춰버리는 크리티컬한 문제가 발생하기도 했고, 디버깅하기 힘든 경우도 있었다. 그런 경험을 하면서 &amp;lsquo;데드락 이 녀석&amp;hellip; 만만치 않구나&amp;lsquo;라는 생각을 하곤 했다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Cache</title><link>https://umi0410.github.io/blog/golang/go-cpu-cache/</link><pubDate>Wed, 27 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-cpu-cache/</guid><description>시작하며 저번 학기에 컴퓨터 구조를 수강하면서 간과하고 있던 로우 레벨의 지식에도 흥미가 생겼었다. 그 중 CPU와 Memory, Disk의 역할에 대해 알아볼 수 있었고 캐시는 CPU와 Memory 사이에 위치해 메모리 대신 빠르게 CPU에게 데이터를 제공하는 녀석이라고 배웠다.
이전에는 주로 캐시라고 하면 주로 CDN과 같은 네트워크에서 쓰이는 캐시들밖에 몰랐다. 그렇다보니 L1 캐시, L2 캐시 같은 얘기를 들으면 OSI 7계층과 연관 지어 &amp;lsquo;음..? L2 캐시는 스위치에서 쓰는 캐시인가..?&amp;rsquo; 라는 상상을 하곤했다.
이번에는 Go를 통해 배열에 여러 차례 접근하는 프로그램을 만들어보고 벤치마킹을 통해 캐시라는 녀석이 어떤 효과를 가져다주는지 직접 확인해보려한다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Socket (Unix Domain Socket, Network/TCP/UDP Socket)</title><link>https://umi0410.github.io/blog/golang/go-socket/</link><pubDate>Sat, 13 Feb 2021 14:10:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-socket/</guid><description>시작하며 개발 공부를 처음 시작한 지 언제 안 됐을 무렵, 의경 복무를 하며 자바로 TCP Socket을 이용해 옆 컴퓨터와 채팅을 하는 프로그램을 만들어 보는 것을 시작으로 docker나 mysql과 같은 다양한 오픈소스들을 이용해보면서나 네트워크를 공부하면서 다양하게 들어왔던 소켓이지만 정확히 어떤 역할을 하는지 어떤 종류가 있는지 어떻게 동작하는지 알지 못했다.
오늘은 그렇게 알쏭달쏭한 존재였던 소켓을 크게 Unix Domain Socket와 Network Socket 두 가지로 나눠 정리해보고 Unix Domain Socket과 TCP를 사용하는 Network Socket을 벤치마크해보고 어떤 차이가 있는지 확인해보도록 하겠다.</description></item></channel></rss>