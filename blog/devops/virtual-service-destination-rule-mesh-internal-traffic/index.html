<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="시작하며 데브옵스 엔지니어로 입사한 뒤 주로 맡고 있는 작업은 Istio 관련 작업이다. 평소 참 관심 있었던 분야이기도 하고 istio 뿐만 아니라 네트워크에 대해 개인적으로 정말 공부해보고싶었는데 덕분에 재미있게 공부하고 성장하며 근무하고 있는 것 같다. 😊
근데 요즘 들어 점점 단순히 ‘어떻게 저떻게 하니까 돌아는가네~ 오.. 나 istio 좀 파악한듯?ㅋㅋ’ 수준의 자세로는 트러블슈팅을 하거나 올바르게 설계하기가 쉽지 않은 경우들이 잦아졌다.
따라서 평소 궁금했던 내용 중 하나를 살짝 파헤쳐볼까한다.
나는 주로 istio ingress gateway와 관련된 작업을 많이 했었고 이 경우 Virtual Service는 항상 ingress gateway를 참조하도록 설정해왔다."><title>Virtual Service와 Destination Rule을 이용해 mesh 내부 트래픽을 원하는 대로 라우팅해보기</title><link rel=canonical href=https://umi0410.github.io/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Virtual Service와 Destination Rule을 이용해 mesh 내부 트래픽을 원하는 대로 라우팅해보기"><meta property="og:description" content="시작하며 데브옵스 엔지니어로 입사한 뒤 주로 맡고 있는 작업은 Istio 관련 작업이다. 평소 참 관심 있었던 분야이기도 하고 istio 뿐만 아니라 네트워크에 대해 개인적으로 정말 공부해보고싶었는데 덕분에 재미있게 공부하고 성장하며 근무하고 있는 것 같다. 😊
근데 요즘 들어 점점 단순히 ‘어떻게 저떻게 하니까 돌아는가네~ 오.. 나 istio 좀 파악한듯?ㅋㅋ’ 수준의 자세로는 트러블슈팅을 하거나 올바르게 설계하기가 쉽지 않은 경우들이 잦아졌다.
따라서 평소 궁금했던 내용 중 하나를 살짝 파헤쳐볼까한다.
나는 주로 istio ingress gateway와 관련된 작업을 많이 했었고 이 경우 Virtual Service는 항상 ingress gateway를 참조하도록 설정해왔다."><meta property="og:url" content="https://umi0410.github.io/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/"><meta property="og:site_name" content="Jinsu Playground"><meta property="og:type" content="article"><meta property="article:section" content="Blog"><meta property="article:published_time" content="2022-08-11T03:20:00+09:00"><meta property="article:modified_time" content="2022-08-11T03:20:00+09:00"><meta property="og:image" content="https://umi0410.github.io/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/preview.png"><meta name=twitter:title content="Virtual Service와 Destination Rule을 이용해 mesh 내부 트래픽을 원하는 대로 라우팅해보기"><meta name=twitter:description content="시작하며 데브옵스 엔지니어로 입사한 뒤 주로 맡고 있는 작업은 Istio 관련 작업이다. 평소 참 관심 있었던 분야이기도 하고 istio 뿐만 아니라 네트워크에 대해 개인적으로 정말 공부해보고싶었는데 덕분에 재미있게 공부하고 성장하며 근무하고 있는 것 같다. 😊
근데 요즘 들어 점점 단순히 ‘어떻게 저떻게 하니까 돌아는가네~ 오.. 나 istio 좀 파악한듯?ㅋㅋ’ 수준의 자세로는 트러블슈팅을 하거나 올바르게 설계하기가 쉽지 않은 경우들이 잦아졌다.
따라서 평소 궁금했던 내용 중 하나를 살짝 파헤쳐볼까한다.
나는 주로 istio ingress gateway와 관련된 작업을 많이 했었고 이 경우 Virtual Service는 항상 ingress gateway를 참조하도록 설정해왔다."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://umi0410.github.io/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/preview.png"><link rel="shortcut icon" href=https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/241/whale_1f40b.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177403492-1","auto"),ga("send","pageview"))</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=East+Sea+Dokdo&family=Noto+Sans+KR:wght@400&display=swap" rel=stylesheet><style>@import 'https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css';:root{--body-background:#fafeff;--base-font-family:Pretendard, 'Noto Sans KR', sans-serif}.site-name{--site-name-font-family:'East Sea Dokdo', cursive;font-family:var(--site-name-font-family);font-size:3.2rem!important}.left-sidebar{--sidebar-avatar-size:200px}figure.site-avatar{margin-left:auto!important;margin-right:auto!important}</style></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://umi0410.github.io class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/><img src=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/preview_hu479968be15567657f18e71d11f31e69a_283588_800x0_resize_box_3.png srcset="/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/preview_hu479968be15567657f18e71d11f31e69a_283588_800x0_resize_box_3.png 800w, /blog/devops/virtual-service-destination-rule-mesh-internal-traffic/preview_hu479968be15567657f18e71d11f31e69a_283588_1600x0_resize_box_3.png 1600w" width=800 height=441 loading=lazy alt="Featured image of post Virtual Service와 Destination Rule을 이용해 mesh 내부 트래픽을 원하는 대로 라우팅해보기"></a></div><div class=article-details><header class=article-category><a href=/categories/devops/>devops</a>
<a href=/categories/istio/>istio</a>
<a href=/categories/network/>Network</a></header><h2 class=article-title><a href=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/>Virtual Service와 Destination Rule을 이용해 mesh 내부 트래픽을 원하는 대로 라우팅해보기</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Aug 11, 2022</time></footer></div></header><section class=article-content><h2 id=시작하며>시작하며</h2><p>데브옵스 엔지니어로 입사한 뒤 주로 맡고 있는 작업은 <code>Istio</code> 관련 작업이다. 평소 참 관심 있었던 분야이기도 하고 istio 뿐만 아니라 네트워크에 대해 개인적으로 정말 공부해보고싶었는데 덕분에 재미있게 공부하고 성장하며 근무하고 있는 것 같다. 😊</p><p>근데 요즘 들어 점점 단순히 ‘어떻게 저떻게 하니까 돌아는가네~ 오.. 나 istio 좀 파악한듯?ㅋㅋ’ 수준의 자세로는 트러블슈팅을 하거나 올바르게 설계하기가 쉽지 않은 경우들이 잦아졌다.</p><p>따라서 평소 궁금했던 내용 중 하나를 살짝 파헤쳐볼까한다.</p><p>나는 주로 istio <code>ingress gateway</code>와 관련된 작업을 많이 했었고 이 경우 Virtual Service는 항상 ingress gateway를 참조하도록 설정해왔다. 근데 istio를 처음 배울 때는 분명 ‘client 측에서 outbound handler로서의 Envody 사이드카을 통해 알아서 우리가 의도하는 목적지를 찾아서 요청을 보낸다.’ 이런 식으로 배웠던 것 같은데 ‘왜 나는 Virtual Service를 이용할 때 항상 Gateway를 설정해줘야하는 것이었을까?’하는 궁금증이 생겼다.</p><ul><li><strong>Virtual Service는 Gateway에 ingress gateway를 설정해주지 않아도 되는 것일까?</strong></li><li><strong>Virtual Service에 설정한 내용은 ingress gateway로 들어온 요청뿐만 아니라 mesh 내부에서의 요청에도 적용될 수 있는 것인가?</strong></li><li><strong>Destination Rule은 뭐하는 녀석일까? 주로 얘는 Virtual Service와 함께 쓰는 예시가 많이 보이던데 꼭 Virtual Service와 함께 써야하는 걸까?</strong></li></ul><p>따라서 이번 글에서는 위와 같은 궁금증들에 대해 삽질해본 내용을 정리해보려한다. 작업해본 내용은 아래와 같다.</p><ol><li><strong>ingress gateway를 통해 들어오는 요청이 아니라 mesh 내부에서 보내는 요청에 대해 적용될 수 있도록 Virtual Service를 정의한 뒤 mesh 내부에서 요청을 보내보기</strong></li><li><strong>Virtual Service 없이 Destination 이용해보기</strong></li></ol><h2 id=virtual-service와-destination-rule에-대해-짚고-넘어가보자>Virtual Service와 Destination Rule에 대해 짚고 넘어가보자.</h2><blockquote><p>virtual services as how you route your traffic to a given destination, and then you use destination rules to configure what happens to traffic for that destination. Destination rules are applied after virtual service routing rules are evaluated, so they apply to the traffic’s “real” destination.</p></blockquote><p><a class=link href=https://istio.io/latest/docs/concepts/traffic-management/#destination-rules target=_blank rel=noopener>https://istio.io/latest/docs/concepts/traffic-management/#destination-rules</a></p><blockquote></blockquote><p>istio를 처음 배울 때에는 (물론 이 글을 쓰기 전까지도.. ㅎㅎ;;) Virtual Service와 Destination Rule이 참 헷갈렸다.</p><p>Virtual Service는 Gateway를 통해 <code>hosts</code> 설정한 호스트를 이용해 들어온 요청을 어떤 기준으로 어떤 (약간은 가상인) 목적지로 보내줄 것인가를 의미한다. 이 말도 좀 헷갈릴 수 있는데 예를 들면 다음과 같다.</p><ul><li>ingress gateway 를 통해</li><li>Virtual Service의 hosts인 [”<a class=link href=http://foo.jinsu.me/ target=_blank rel=noopener>foo.jinsu.me</a>”] 중 하나인 foo.jinsu.me를 이용해 들어온 요청을</li><li>subset이나 weight에 따라 foo v1 이나 foo v2 로 보낸다.</li></ul><p>위와 같은 설정을 해주는 것이 Virtual Service이다.</p><p>그럼 foo v1과 foo v2는 누가 정의해줄까? 귀신 같이 알아서 v1에 대한 endpoint와 v2에 대한 endpoint를 분류할 수는 없을텐데 말이다. 바로 이때 Destination Rule이 등장한다.</p><p>Destination Rule은 어떤 기준으로 특정 Service(쿠버의 기본 리소스 타입)에 대한 subset을 나눌지 정의할 수 있다. 혹은 그 외에도 기본적으로 Service가 제공하지 않는 유용한 방식들을 통해 Endpoint가 관리될 수 있도록 해준다. 이때 말하는 Endpoint는 쿠버의 기본 리소스 타입 중 하나인 Endpoint가 아니라 Destination Rule을 통해 실제로 트래픽이 흘려보내진다는 의미의 Endpoint를 의미한다.</p><p>근데 뭐,,, 나름대로 두 개념을 정리해보려했는데 시원한 정리는 아닌 것 같다… 쓰다보면 감이오는데 아직 딱 깔끔하게 정리할 수 있는 수준의 이해는 아닌가보다.</p><h2 id=mesh-내부의-통신에서도-virtual-service나-destination-rule이-동작하는가>mesh 내부의 통신에서도 virtual service나 destination rule이 동작하는가?</h2><p>앞서 Virtual Service에 대해 설명할 때 “Gateway를 통해 들어온 요청이 …(생략)” 이라며 설명을 했는데 그렇다면 <strong>Virtual Service는 ingress gateway를 통해 들어온 요청에 대한 설정만 정의가 가능하냐라고하면 그건 당연히 아니다.</strong> 애초에 istio를 통해 우리가 얻고 싶은 것은 ingress에 대한 기능뿐만 아니라 mesh 내부 통신에 대한 기능도 큰 부분일 것이니 말이다.</p><blockquote><p>The reserved word mesh is used to imply all the sidecars in the mesh. When this field is omitted, the default gateway (mesh) will be used, which would apply the rule to all sidecars in the mesh.</p></blockquote><p><a class=link href=https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService target=_blank rel=noopener>https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService</a></p><blockquote></blockquote><p><strong>Virtual Service가 <code>mesh</code> 라는 예약된 gateway 이름을 이용하면 그것은 mesh 내의 sidecar들에게 모두 적용되는 rule이 된다.</strong> Virtual Service의 gatewaymesh 내부 통신에 있어 Virtual Service의 역할이 큼에도 불구하고 아이러니하게도 위와 같은 내용을 찾아볼 수 있는 문서가 많지는 않았다.</p><p>정리하자면 “mesh 내부의 통신에서도 virtual service나 destination rule이 동작하는가?”에 대한 대답은 아래와 같다.</p><ul><li><strong>Virtual Service의 gateways에 <code>mesh</code> 가 포함되어있거나 <code>gateways</code> 가 정의되지 않았고, client 측 envoy sidecar가 inbound handler 역할을 수행한다면 → YES</strong></li><li>Virtual Service의 gateways를 정의했는데 <code>mesh</code> 가 포함되어있지 않다면 → NO</li><li>client 측 envoy sidecar가 존재하지 않거나 inbound handler 역할을 제대로 수행하지 못한다면 → NO</li></ul><p>그럼 한 번 실습을 통해 확인해보자.</p><h2 id=mesh-내부-통신에서-virtual-service--destination-rule을-통해-service-subset과-weight-이용해보기>mesh 내부 통신에서 Virtual Service + Destination Rule을 통해 Service subset과 weight 이용해보기</h2><p><code>httpping-without-sidecar</code>라는 이름의 서비스를 배포해두었고, 이는 golang으로 만들어진 요청이 들어올 때 “pong” 로그를 남기는 단순한 웹 애플리케이션이다. 이 서비스의 Pod들은 Envoy 사이드카를 주입받지 않는다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ kubectl get pod -l <span class=nv>app</span><span class=o>=</span>httpping-without-sidecar
</span></span><span class=line><span class=cl>NAME                                           READY   STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>httpping-without-sidecar-v1-7fd6bfdb57-bcpdh   1/1     Running   <span class=m>0</span>          2m54s
</span></span><span class=line><span class=cl>httpping-without-sidecar-v1-7fd6bfdb57-s4smn   1/1     Running   <span class=m>0</span>          2m54s
</span></span><span class=line><span class=cl>httpping-without-sidecar-v1-7fd6bfdb57-zg8td   1/1     Running   <span class=m>0</span>          2m54s
</span></span><span class=line><span class=cl>httpping-without-sidecar-v2-5df8b7f656-n4cvh   1/1     Running   <span class=m>0</span>          2m53s
</span></span><span class=line><span class=cl>httpping-without-sidecar-v2-5df8b7f656-nfm6q   1/1     Running   <span class=m>0</span>          2m53s
</span></span><span class=line><span class=cl>httpping-without-sidecar-v2-5df8b7f656-vbgpr   1/1     Running   <span class=m>0</span>          2m53s
</span></span></code></pre></div><p>v1 과 v2에 대한 Deployment 각각 배포해두었다.</p><p>각 버전별로 3개의 Pod가 배포되어있다.</p><p>버전 별로 Pod들은 다음과 같이 라벨이 붙어있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># v1 Pod의 경우</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># v2 Pod의 경우</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=l>v2</span><span class=w>
</span></span></span></code></pre></div><p>Service, Destination Rule, Virtual Service는 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>infra-jinsu-lab</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>Service는 version을 명시하지 않은 채 app만을 명시하는 수퍼셋으로서 정의했다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>networking.istio.io/v1alpha3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>DestinationRule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>infra-jinsu-lab</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar-destination</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>subsets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=l>v2</span><span class=w>
</span></span></span></code></pre></div><p>Destination Rule은 Service에 해당하는 Endpoint들의 Subset처럼 정의된다.</p><p>version 라벨이 추가되었다.</p><p>host는 Service를 가리킬 수 있는 이름이어야한다. 같은 네임스페이스일 경우 Short name으로 표현할 수도 있고, 언제는 FQDN(e.g. httpping-with-sidecar.infra-jinsu.lab.svc.cluster.local)으로 표현할 수도 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>networking.istio.io/v1alpha3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>VirtualService</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>infra-jinsu-lab</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hosts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=s2>&#34;httpping-without-sidecar&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>gateways</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>mesh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>http</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>match</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>uri</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>prefix</span><span class=p>:</span><span class=w> </span><span class=l>/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>route</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>destination</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>subset</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>number</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>weight</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>destination</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>subset</span><span class=p>:</span><span class=w> </span><span class=l>v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>number</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>weight</span><span class=p>:</span><span class=w> </span><span class=m>90</span><span class=w>
</span></span></span></code></pre></div><p>앞서 말한대로 클러스터 내부 통신에 대해 Virtual Service를 적용하려면 <code>gateways</code> 를 생략하거나 <code>mesh</code> 라는 예약된 이름의 게이트웨이를 포함시켜준다. 또한 mesh 내부 통신에 대해서는 hosts에 Destination Rule처럼 Service를 참조할 수 있는 이름을 적어준다.</p><p>그리고서는 Destination Rule에서 정의한 v1 subset은 weight를 10으로, v2 subset은 weight를 90으로 설정해줬다. 이렇게 되면 <strong>누군가가 서비스를 향해 요청을 보냈을 때 v1과 v2가 1대9의 비율로 로드밸런스가 될 것이다</strong> 🙂</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -H <span class=s1>&#39;foo: bar&#39;</span> http://httpping-without-sidecar.infra-jinsu-lab:8080/ping
</span></span></code></pre></div><p><figure style=flex-grow:181;flex-basis:435px><a href=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/weight.png data-size=2558x1409><img src=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/weight.png srcset="/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/weight_hu479968be15567657f18e71d11f31e69a_283588_480x0_resize_box_3.png 480w, /blog/devops/virtual-service-destination-rule-mesh-internal-traffic/weight_hu479968be15567657f18e71d11f31e69a_283588_1024x0_resize_box_3.png 1024w" width=2558 height=1409 loading=lazy alt="좌측은 weight가 10인 v1 Pod 3개 | 우측은 weight가 90인 v2 Pod 3개"></a><figcaption>좌측은 weight가 10인 v1 Pod 3개 | 우측은 weight가 90인 v2 Pod 3개</figcaption></figure></p><p>Envoy 사이드카가 삽입된 어떤 Pod에서 위의 커맨드를 통해 <code>httpping-without-sidecar</code> 서비스로 요청을 보낸 경우의 모습이다. 좌측 로그는 v1 Pod 3개의 로그이고, 우측 로그는 v2 Pod 3개의 로그이다.</p><p><strong>Virtual Service에서 정의한대로 대부분의 트래픽은 v2로 흘러갔고 Destination Rule에서 정의한 대로 v1, v2에 대한 subset이 잘 분류된 듯하다!</strong></p><p>참고로 당연히도 클라이언트 측에서 Enovy가 outbound handling을 해주지 못한다면(혹은 sidecar가 삽입되지 않았다면) weight 조절도 되지 않고 그냥 라운드로빈으로 부하가 분산될 것이다.</p><h2 id=virtual-service-없이-destination-rule만으로-원하는-방식을-통해-부하-분산시키기>Virtual Service 없이 Destination Rule만으로 원하는 방식을 통해 부하 분산시키기</h2><p>이번에는 <strong>Virtual Service 없이 Destination Rule의 기능 중 하나인 consistentHash를 통한 로드밸런스를 해볼 것이다. 이를 이용하면 특정 키에 대한 값을 해싱해서 해당 해시 값을 담당하는 Pod에게 요청을 보낼 것이다!</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ kubectl delete virtualservice httpping-without-sidecar
</span></span><span class=line><span class=cl>virtualservice.networking.istio.io <span class=s2>&#34;httpping-without-sidecar&#34;</span> deleted
</span></span></code></pre></div><p>Virtual Service 없이 동작함을 분명히 하기 위해 삭제해준다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>networking.istio.io/v1alpha3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>DestinationRule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>infra-jinsu-lab</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar-destination</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>httpping-without-sidecar</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>trafficPolicy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>loadBalancer</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>consistentHash</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>httpHeaderName</span><span class=p>:</span><span class=w> </span><span class=l>foo</span><span class=w>
</span></span></span></code></pre></div><p>이번에는 Destination을 위와 같이 작성해줌으로써 헤더 중 foo라는 키에 대한 값에 따라 부하가 분산되도록 할 것이다. <strong>같은 값으로 요청을 보내면 담당하는 해시 값이 변경되지 않는 한 같은 Pod로만 요청</strong>이 갈 것이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -H <span class=s1>&#39;foo: bar&#39;</span> http://httpping-with-sidecar.infra-jinsu-lab:8080/ping
</span></span></code></pre></div><p>Envoy 사이드카가 삽입되어 outbound handler가 잘 동작 중인 다른 Pod에서 위와 같이 요청을 여러 차례 보내봤다.</p><p><figure style=flex-grow:183;flex-basis:440px><a href=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/consistent-hash.png data-size=2560x1395><img src=/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/consistent-hash.png srcset="/blog/devops/virtual-service-destination-rule-mesh-internal-traffic/consistent-hash_huec96e079d93944483a2dbb05770995ea_198415_480x0_resize_box_3.png 480w, /blog/devops/virtual-service-destination-rule-mesh-internal-traffic/consistent-hash_huec96e079d93944483a2dbb05770995ea_198415_1024x0_resize_box_3.png 1024w" width=2560 height=1395 loading=lazy alt="Consistent Hash 설정 후 foo: bar라는 동일한 헤더로 요청을 보낸 경우의 로그"></a><figcaption>Consistent Hash 설정 후 foo: bar라는 동일한 헤더로 요청을 보낸 경우의 로그</figcaption></figure></p><p>위와 같이 하나의 Pod로만 요청이 간 것을 확인할 수 있었다!</p><h2 id=마치며>마치며</h2><p>이번 주에 업무가 정말 많았는데 이래 저래 오갔던 대화 중에 헷갈리는 부분이 있어서 갑자기 야밤에 이렇게 내용을 정리해봤다. 공식 문서를 다시 한 번 정독한 뒤 ‘아~ 얘의 역할은 이거니까 이렇게 하면 이렇게 되겠군!’이라며 살짝쿵 이해를 한 뒤에 실습을 해봤고 결과가 잘 나와서 뿌듯하다. 맘 편히 잘 수 있을 듯.</p><p>다만 문서 내용과 컨셉들의 “역할"이나 “의미"에 대한 이해 뿐만 아니라 실제 동작 플로우까지도 알고 싶은 마음은 있는데 너무 조급해하는 것보다는 빠르진 않더라도 꾸준하게 이렇게 하나 하나 공부해나가면 될 것이라고 믿는다!</p><h2 id=참고>참고</h2><ul><li>각종 istio 문서들<ul><li>Traffic Management 컨셉 <a class=link href=https://istio.io/latest/docs/concepts/traffic-management/ target=_blank rel=noopener>https://istio.io/latest/docs/concepts/traffic-management/</a></li><li>Traffic Management, Networking config 관련 문서 <a class=link href=https://istio.io/latest/docs/reference/config/networking/ target=_blank rel=noopener>https://istio.io/latest/docs/reference/config/networking/</a></li></ul></li><li>Using Istio VirtualService from inside of the cluster - <a class=link href=https://stackoverflow.com/questions/65626962/using-istio-virtualservice-from-inside-of-the-cluster target=_blank rel=noopener>https://stackoverflow.com/questions/65626962/using-istio-virtualservice-from-inside-of-the-cluster</a></li></ul></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>관련 글</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/blog/devops/istio-1-10-network-interface/><div class=article-image><img src=/blog/devops/istio-1-10-network-interface/preview.4e9f54549cac5e0bacff136c35e1e401_hu29fb6a1fc6668bac997912987ebc8bfc_15975_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-Tp9UVJysXgus/xNsNeHkAQ=="></div><div class=article-details><h2 class=article-title>istio와 envoy proxy를 통해 경험해보는 네트워크 인터페이스 (istio 1.10)</h2></div></a></article><article class=has-image><a href=/blog/clova-ai-on-k8s/><div class=article-image><img src=/blog/clova-ai-on-k8s/preview.e2045cd085c0bfb60dac5c449c153709_hu0de35698344aa28c3f5141b2d5dcaef6_812038_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-4gRc0IXAv7YNrFxEnBU3CQ=="></div><div class=article-details><h2 class=article-title>쿠버네티스로 Clova AI Custom Extension 배포하기 (feat. Istio, Cert Manager)</h2></div></a></article><article class=has-image><a href=/blog/devops/declarative-argocd-helm-rbac/><div class=article-image><img src=/blog/devops/declarative-argocd-helm-rbac/logo.2f2745030cbf1c98f0f25182b22d48aa_huc6aa4a846d689b08bb4f93a6ab036ab8_63751_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-LydFAwy/HJjw8lGCsi1Iqg=="></div><div class=article-details><h2 class=article-title>ArgoCD 선언적으로 이용해나가기 - Github을 통한 SSO 및 RBAC</h2></div></a></article><article class=has-image><a href=/blog/devops/declarative-argocd-helm-app-of-app/><div class=article-image><img src=/blog/devops/declarative-argocd-helm-app-of-app/logo.2f2745030cbf1c98f0f25182b22d48aa_huc6aa4a846d689b08bb4f93a6ab036ab8_63751_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-LydFAwy/HJjw8lGCsi1Iqg=="></div><div class=article-details><h2 class=article-title>ArgoCD 선언적으로 이용해나가기 - Helm, App of App</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//umi0410.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 Jinsu Playground</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.4.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#시작하며>시작하며</a></li><li><a href=#virtual-service와-destination-rule에-대해-짚고-넘어가보자>Virtual Service와 Destination Rule에 대해 짚고 넘어가보자.</a></li><li><a href=#mesh-내부의-통신에서도-virtual-service나-destination-rule이-동작하는가>mesh 내부의 통신에서도 virtual service나 destination rule이 동작하는가?</a></li><li><a href=#mesh-내부-통신에서-virtual-service--destination-rule을-통해-service-subset과-weight-이용해보기>mesh 내부 통신에서 Virtual Service + Destination Rule을 통해 Service subset과 weight 이용해보기</a></li><li><a href=#virtual-service-없이-destination-rule만으로-원하는-방식을-통해-부하-분산시키기>Virtual Service 없이 Destination Rule만으로 원하는 방식을 통해 부하 분산시키기</a></li><li><a href=#마치며>마치며</a></li><li><a href=#참고>참고</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>