<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.80.0"><meta name=description content="Golang의 Concurrent pattern 중 하나로서 Channel을 바탕으로 커뮤니케이션하며 작업을 진행하는 패턴인
Pipeline pattern에 대해 간략해 소개해봤고, 언제 사용해야할지 그 use case에 대해 알아보았습니다."><meta name=author content="umi0410"><link rel=icon href=https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/241/whale_1f40b.png type=image/png><title>Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns :: Jinsu Playground</title><link href=/css/nucleus.css?1610376579 rel=stylesheet><link href=/css/fontawesome-all.min.css?1610376579 rel=stylesheet><link href=/css/hybrid.css?1610376579 rel=stylesheet><link href=/css/featherlight.min.css?1610376579 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1610376579 rel=stylesheet><link href=/css/auto-complete.css?1610376579 rel=stylesheet><link href=/css/atom-one-dark-reasonable.css?1610376579 rel=stylesheet><link href=/css/theme.css?1610376579 rel=stylesheet><link href=/css/hugo-theme.css?1610376579 rel=stylesheet><link href=/css/theme-umi0410-blue.css?1610376579 rel=stylesheet><link href=/css/custom-umi0410.css?1610376579 rel=stylesheet><script src=/js/jquery-3.3.1.min.js?1610376579></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}:not(pre)>code+span.copy-to-clipboard{display:none}</style></head><body data-url=/blog/golang/golang-concurrent-pattern-pipeline/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=https://umi0410.github.io><span style=font-weight:700;font-size:20px>Jinsu Playground</span></a></div><div id=profile-wrapper><style>#sidebar-profile-message{text-align:left;word-break:keep-all}p{margin-top:0;margin-bottom:0;margin-left:10px;font-size:16px}</style><a href=/><img src=/media/profile.png style=width:170px;margin-top:15px></a><div id=sidebar-profile-message><b>박진수 (umi0410)</b></br><p>Golang, Cloud services, MSA, 컨테이너와 자동화, 깔끔한 아키텍쳐에 관심이 많습니다.</p></div></div></div><div class=highlightable><ul class=topics><li data-nav-id=/portfolio/ title="About Jinsu Park (umi0410)" class=dd-item><a href=/portfolio/>Portfolio</a></li><li data-nav-id=/experiences/ title=Experiences class=dd-item><a href=/experiences/>Experiences</a><ul><li data-nav-id=/experiences/megazone-cloud/ title="메가존 클라우드 데브옵스 인턴 후기" class=dd-item><a href=/experiences/megazone-cloud/><b></b>Megazone Cloud DevOps</a><ul><li data-nav-id=/experiences/megazone-cloud/stargate-infra/ title="Stargate라는 인프라 구축기" class=dd-item><a href=/experiences/megazone-cloud/stargate-infra/><b></b>인프라 구축기</a></li><li data-nav-id=/experiences/megazone-cloud/ci-cd-pipeline/ title="Github Action, Spinnaker을 이용한 CI/CD 파이프라인 구축기" class=dd-item><a href=/experiences/megazone-cloud/ci-cd-pipeline/><b></b>CI/CD 파이프라인</a></li><li data-nav-id=/experiences/megazone-cloud/argo-poc/ title="Argo Project들에 대한 PoC(개념 증명) 진행" class=dd-item><a href=/experiences/megazone-cloud/argo-poc/><b></b>Argo Project PoC</a></li><li data-nav-id=/experiences/megazone-cloud/spaceone-helm/ title="SpaceONE Helm Chart 개발" class=dd-item><a href=/experiences/megazone-cloud/spaceone-helm/><b></b>Helm Chart 개발</a></li><li data-nav-id=/experiences/megazone-cloud/spacectl/ title="SpaceONE CLI Client인 spacectl 설계 및 개발" class=dd-item><a href=/experiences/megazone-cloud/spacectl/><b></b>CLI Client 설계.개발</a></li></ul></li></ul></li><li data-nav-id=/blog/ title=Blog class="dd-item
parent"><a href=/blog/>Blog</a><ul><li data-nav-id=/blog/aws/ title="Category: AWS" class=dd-item><a href=/blog/aws/>AWS</a><ul><li data-nav-id=/blog/aws/aws_eks_elb/ title="EKS K8s에서 ELB(ALB, NLB) 제대로 설정하며 사용하기" class=dd-item><a href=/blog/aws/aws_eks_elb/>EKS K8s에서 ELB(ALB, NLB) 제대로 설정하며 사용하기</a></li></ul></li><li data-nav-id=/blog/golang/ title=Golang class="dd-item
parent"><a href=/blog/golang/>Golang</a><ul><li data-nav-id=/blog/golang/go-vs-java-oop/ title="Go vs Java - Go에서의 객체 지향" class=dd-item><a href=/blog/golang/go-vs-java-oop/><b></b>Go vs Java - Go에서의 객체 지향</a></li><li data-nav-id=/blog/golang/golang-concurrent-pattern-pipeline/ title="Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns" class="dd-item active"><a href=/blog/golang/golang-concurrent-pattern-pipeline/><b></b>Go의 Pipeline pattern. 언제 사용해야할까?</a></li></ul></li></ul></li></ul><section id=shortcuts><h3>More</h3><ul><li><a class=padding href=https://github.com/umi0410><i class="fab fa-github"></i>Github</a></li></ul></section><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a>from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=top-github-link><a class=github-link title="Edit this page" href=https://github.com/umi0410/umi0410.github.io/edit/master/content/blog/golang/golang-concurrent-pattern-pipeline.md target=blank><i class="fas fa-code-branch"></i><span id=top-github-link-text>Edit this page</span></a></div><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span><span id=toc-menu><i class="fas fa-list-alt"></i></span><span class=links><a href=/>About Jinsu Park (umi0410)</a> > <a href=/blog/>Blog</a> > <a href=/blog/golang/>Golang</a> > Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#-시작하며>✋ 시작하며</a></li><li><a href=#-pipeline-pattern이란>❓ Pipeline pattern이란?</a><ul><li><a href=#pipeline-pattern의-흔한-예시로-square-하는-예제를-설명하는-글들>Pipeline pattern의 흔한 예시로 square 하는 예제를 설명하는 글들</a></li></ul></li><li><a href=#-언제-쓰는-게-좋을까>🤔 언제 쓰는 게 좋을까?</a></li><li><a href=#예시-프로그램>예시 프로그램</a><ul><li><a href=#프로그램-설명>프로그램 설명</a></li><li><a href=#-벤치마크-결과-비교>📉 벤치마크 결과 비교</a></li></ul></li><li><a href=#마무리>마무리</a></li><li><a href=#참고>참고</a></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns</h1><div class=wrapper><hr style=margin-top:20px;margin-bottom:20px></hr><b>Table of Contents</b><nav id=TableOfContents><ul><li><a href=#-시작하며>✋ 시작하며</a></li><li><a href=#-pipeline-pattern이란>❓ Pipeline pattern이란?</a><ul><li><a href=#pipeline-pattern의-흔한-예시로-square-하는-예제를-설명하는-글들>Pipeline pattern의 흔한 예시로 square 하는 예제를 설명하는 글들</a></li></ul></li><li><a href=#-언제-쓰는-게-좋을까>🤔 언제 쓰는 게 좋을까?</a></li><li><a href=#예시-프로그램>예시 프로그램</a><ul><li><a href=#프로그램-설명>프로그램 설명</a></li><li><a href=#-벤치마크-결과-비교>📉 벤치마크 결과 비교</a></li></ul></li><li><a href=#마무리>마무리</a></li><li><a href=#참고>참고</a></li></ul></nav><hr style=margin-top:0;margin-bottom:0></hr></div><h2 id=-시작하며>✋ 시작하며</h2><p><code>Go</code>를 공부하기 시작한 지도 벌써 몇 달이 지난 것 같다. 데브옵스 인턴을 마치면서 특히나 관심있었던 Go를 공부하기 시작했었고, 지난 몇 달간 AWS KRUG내의 소모임인 AUSG의 스터디 활동으로 Go를 주제로 공부해왔다. Golang의 꽃이라고 할 수 있는 요소들이 몇 개 있었는데 나는 그 중 <code>goroutine</code>과 <code>channel</code>에서 매력을 느꼈고 그를 바탕으로한 <code>concurrency pattern</code>들에 대해 이래 저래 많이 알아봐왔다.</p><p>하지만 concurrency pattern이 뭐고, 어떻게 사용하는지에 대해서는 여러 글을 찾아볼 수 있었지만 이게 왜 좋고 언제 쓰면 좋을지에 대한 내용은 찾아보기 힘들었다. 항상 어떤 기술을 접할 때 &ldquo;<em>왜 좋은데?</em>&ldquo;와 &ldquo;<em>언제 쓰면 좋은데?</em>&ldquo;를 많이 따지는 편이라서 늘 궁금증에 남아있었다.</p><p>그러던 중 얼마 전 나의 궁금증을 해소시켜주는 간단한 댓글을 보게 되었고, 그를 바탕으로 몇 가지 서치를 해본 결과 concurrency pattern 중 하나인 <code>pipeline pattern</code>을 언제 쓰면 좋을지 알아보았다.</p><h2 id=-pipeline-pattern이란>❓ Pipeline pattern이란?</h2><p><img src=illustration.png alt=illustration.png></p><p>Pipeline pattern은 golang의 Concurrency pattern 중 하나이다. 쉽게 말하자면 함수의 인자에 값을 전달해 작업하는 것이 아니라 <code>channel</code> 을 통해 실시간으로 <strong>함수(혹은 goroutine)들끼리 커뮤니케이션을 하며 작업을 진행</strong>하는 것이다. 실시간으로 함수들끼리 커뮤니케이션하며 data를 전송하기 때문에 data streaming 같은 느낌이라고 볼 수 있겠다.</p><p>일반적으로는 한 함수에서 작업이 모두 끝난 뒤 그 결과값을 리턴하고, 또 다시 그 결과 값을 인풋으로 어떤 함수가 작업을 하고 해당 작업이 모두 끝난 뒤 또 다른 결과값을 리턴하는 형태로 진행이 된다. 하지만 Pipeline pattern에서는 한 작업이 모두 완료되지 않았다하더라도 해당 작업의 부분 부분의 데이터를 담는 channel을 리턴하고, 다른 작업은 해당 channel을 인풋으로 하여 부분 부분의 데이터를 channel에서 꺼내 바로 바로 작업한다.</p><p><img src=python-generator.png alt=python-generator.png></p><p><em><center>generator을 이용한 lazy evaluation. 0, 1, 2를 모두 Insert한 뒤 square and print 하는 것이 아닌 하나씩 실시간으로 진행</center></em></p><p>이는 마치 <strong>Python의 <code>Generator</code>을 통한 <code>Lazy evaluation</code>을 이용할 때와 유사</strong>하게 볼 수는 있겠다. 하지만 많은 차이점이 존재하긴 할텐데 우선 generator는 thread-safe하지 않은(<a href=https://stackoverflow.com/questions/1131430/are-generators-threadsafe>stackoverflow 참고</a>) 반면 channel은 여러 goroutine에서 한 channel에 접근해도 thread-safe하다. &lsquo;thread-safe한가&rsquo;가 중요한 이유는 후에 잠깐 소개할 <code>fan-in fan-out pattern</code>이 바로 pipeline pattern이 여러 goroutine에서 이루어지는 경우이기 때문이다.</p><p>(<em>사실 내가 Pipeline pattern을 어디에 사용할 지 몰랐던 이유는 Lazy evaluation과 같은 개념이 없었기 때문이 아닐까싶기도 하다.</em>)</p><h3 id=pipeline-pattern의-흔한-예시로-square-하는-예제를-설명하는-글들>Pipeline pattern의 흔한 예시로 square 하는 예제를 설명하는 글들</h3><p>종종 Pipeline pattern의 예시를 알아보면서 square 작업을 하는 예제들을 몇 개 봤던 것 같은데, 그 중 참고할 수 있는 예시들을 제시해본다. square 작업이 pipeline pattern에 효율적이라기보다는 그냥 임의의 예시라고 생각한다.</p><p>이 글은 Pipeline pattern을 언제 사용하면 좋을지에 초점을 맞추었기에 Pipeline pattern이 뭔지, 그 사용법은 어떻게 되는지 등의 내용을 모르는 상태라면 아래 글들을 추천한다. (특히 Aidan Bae님의 블로그에는 pipeline pattern 외에도 다양한 Go 관련 내용을 잘 적혀있다.)</p><ul><li>Aidan Bae님의 아주 간단한 Pipeline pattern 예시 - <a href=https://aidanbae.github.io/code/golang-design/pipeline/>https://aidanbae.github.io/code/golang-design/pipeline/</a></li><li>GoBlog의 간단한 내용부터 꽤나 어려운 내용까지 들어가는 것 같은데, 내용도 길고 짧은 코드에 억지로 많은 내용을 끼워넣은 느낌.. <a href=https://blog.golang.org/pipelines>https://blog.golang.org/pipelines</a></li></ul><h2 id=-언제-쓰는-게-좋을까>🤔 언제 쓰는 게 좋을까?</h2><p>앞선 lazy evaluation 관련된 내용과 <a href=https://www.reddit.com/r/golang/comments/7rjdw6/go_go_go_stream_processing_for_go/>이 글의 댓글</a>(go로 작업을 stream하라는 글에 &ldquo;<em>너 정말 저렇게 stream하는 게 좋다고 생각해? 이 경우 아니면 그닥 잘 모르겠는데?</em>&ldquo;라는 댓글)이 나의 이해를 도와주었다. <a href=https://labs.bawi.io/7-reasons-to-use-pipeline-architecture-93346f604b87>Pipeline architecture를 사용해야하는 7가지 이유라는 글</a>을 읽어보기도 했지만 여기의 내용은 실질적으로 왜 그 장점을 갖는지에 대한 설명이나 논리가 부족했다. (<em><del>다소 Go와 Pipeline pattern에 대한 무조건적 사랑으로 느껴짐..ㅎㅎ&mldr;</del></em>)</p><p>내 생각에는 아래 두 가지 경우에 Pipeline pattern을 이용하는 것이 좋을 것 같다.</p><ul><li><strong>Input 작업을 모두 수행하는 데에 오랜 시간이 걸리는 경우</strong></li><li><strong>작업하는 데이터의 양이 너무 커서 Memory를 많이 점유하므로 쪼개서 바로 바로 처리하고 싶은 경우</strong></li></ul><p>&lsquo;<em>디버깅하기 쉽다</em>&lsquo;거나 &lsquo;<em>코드를 알아보기 쉽다</em>&rsquo; 등등의 글을 보긴했던 것 같은데 개인적으로는 그냥 pipeline과 channel을 안 쓰고 그냥 반복문을 돌리면서 데이터를 통째로 작업하는 게 디버깅이나 가독성면으로 훨씬 유리하다고 생각한다. 즉 Concurrent pattern의 장점은 특정 use case에서의 성능적인 측면이라고 생각한다.</p><p>그리고 이건 여담인데 <strong>go의 channel을 통한 data 전달이 일반적으로 빠른 건 절대 아니다.</strong> channel은 우선 <code>thread safe</code>하기때문에 일반적인 작업에서는 <strong>thread-unsafe한 방식보다 느린 것이 당연</strong>하다. 또한 channel은 단순한 lock 기능 외에도 다른 goroutine(혹은 thread 혹은 function) 간의 데이터 전송, channel에 대한 반복, 열었는지 닫았는지에 대한 체크 등등 다양한 기능도 갖고있기때문에 <strong>mutex에 비해서도 훨씬 느린 듯하다</strong>. 그렇기 때문에 위에서 나열했듯 Input 작업이 오래 걸리거나 Memory 점유량을 줄이기 위한 경우에는 channel을 이용한 Pipeline pattern으로 실시간으로 작업하면 유리할 것이라고 생각한 것이다.</p><p>그리고 추가적으로 앞에서 <code>Fan-in Fan-out</code> pattern에서는 여러 Goroutine에 대한 Pipeline pattern이 적용된다고했는데, Fan-in Fan-out이란 여러 goroutine이 하나의 channel에 값을 넣거나 빼는 구조를 말한다. 이 구조의 장점은 일반적인 Pipeline Pattern에서 각 단계가 하나의 goroutine만을 이용하는 것이 아니라 여러 goroutine을 이용할 수 있다는 점이다. CPU bound한 작업이 아닌 IO Block이 주요 latency를 차지하는 경우는 Goroutine을 늘려주면 concurrent하게 작업할 수 있기때문에 성능이 좋아지더라. Fan-in Fan-out pattern에 대해서는 기회가 된다면 더 자세히 다뤄보겠다.</p><p><strong>참고</strong></p><ul><li>Mutex보다 channel이 느리다는 벤치마크 글 - <a href=http://www.dogfootlife.com/archives/452>http://www.dogfootlife.com/archives/452</a></li><li>Mutex를 쓸 수 있는 상황이면 Mutex를 쓰는 것이 좋을 수도 있다 - <a href=https://github.com/golang/go/wiki/MutexOrChannel>https://github.com/golang/go/wiki/MutexOrChannel</a></li></ul><h2 id=예시-프로그램>예시 프로그램</h2><h3 id=프로그램-설명>프로그램 설명</h3><p>Input 작업을 수행하는 데에 오랜 시간이 걸리는 경우를 예시로 들기 위해 MySQL에서 Gopher에 대한 데이터를 조회한 뒤 Gopher들의 연령을 +10 증가시키는 예시를 만들어봤다.</p><p>Input 작업을 모두 수행하는 데에 오래 걸리고, 작업 내용을 조금씩 쪼갤 수 있다는 전제조건을 위해 DB Query를 할 때 전체를 한 번에 Select 하는 것이 아니라 1개씩 Select하는 다소 비효율적이고 비현실적인 상황을 이용하긴하지만 간단하게 Pipeline pattern의 효율을 극대화시켜보고자했던 이유이므로 양해를 부탁드린다.</p><p>예를 들어 Pipeline pattern을 통해 <strong>1000개의 Row를 Query하고 난 뒤 1000개를 Update하는 것이 아니라 1000개의 Row를 Query하면서 1개 1개의 Row를 얻어올 때 마다 바로바로 Update 작업에 Row를 넘겨줘 실시간으로 작업</strong>할 수 있게해주는 것이다.</p><ul><li>Pipeline pattern: 한 item 씩 실시간으로 전달하며 진행</li><li>Sequential pattern: 딱히 Pattern이라기엔 좀 그렇지만 그냥 일반적으로 Sequential하게 진행하는 경우를 의미. 이 예시에선 전체 Query 완료 후 전체 Update하는 방식.</li></ul><p>Docker를 이용해 간단하게 MySQL 서버를 띄웠고, Gorm을 이용해 DB Query와 update를 수행했다.</p><div class=expand><div class=expand-label style=cursor:pointer onclick="$h=$(this);$h.next('div').slideToggle(100,function(){$h.children('i').attr('class',function(){return $h.next('div').is(':visible')?'fas fa-chevron-down':'fas fa-chevron-right';});});"><i style=font-size:x-small class="fas fa-chevron-right"></i><span>예시 프로그램 코드</span></div><div class=expand-content style=display:none><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;github.com/brianvoe/gofakeit/v6&#34;</span>
	<span style=color:#e6db74>&#34;gorm.io/driver/mysql&#34;</span>
	<span style=color:#75715e>//&#34;gorm.io/driver/sqlite&#34;
</span><span style=color:#75715e></span>	<span style=color:#e6db74>&#34;gorm.io/gorm&#34;</span>
	<span style=color:#e6db74>&#34;gorm.io/gorm/logger&#34;</span>
	<span style=color:#e6db74>&#34;math/rand&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>NumTotalData</span>      <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>100</span> <span style=color:#75715e>// 초기화할 데이터
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>NumManipulateData</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>100</span> <span style=color:#75715e>// fetch 후 map을 적용할 데이터 수
</span><span style=color:#75715e></span>)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Gopher</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>Model</span>
	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>Age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>initializeDB</span>(<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>) {
	<span style=color:#75715e>// Migrate the schema
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>AutoMigrate</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Gopher</span>{})

	<span style=color:#75715e>// Create initial data
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>NumTotalData</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>gopher</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Gopher</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#a6e22e>gofakeit</span>.<span style=color:#a6e22e>Name</span>(), <span style=color:#a6e22e>Age</span>: <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>60</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>}
		<span style=color:#a6e22e>gopher</span>.<span style=color:#a6e22e>ID</span> = uint(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Save</span>(<span style=color:#a6e22e>gopher</span>)
	}
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Initialized DB&#34;</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SequentialPattern</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>DB</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>
}
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PipelinePattern</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>DB</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>DB</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>SequentialPattern</span>) <span style=color:#a6e22e>Execute</span>() {
	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>Map</span>(<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>FetchData</span>())
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sequential&#34;</span>, <span style=color:#a6e22e>sp</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Elapsed:&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
	<span style=color:#a6e22e>gophers</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>Gopher</span>, <span style=color:#ae81ff>0</span>)
	<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Limit</span>(<span style=color:#a6e22e>NumTotalData</span>).<span style=color:#a6e22e>Find</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gophers</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Average age(Num: %d): %d\n&#34;</span>, len(<span style=color:#a6e22e>gophers</span>), <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span>{
	  <span style=color:#a6e22e>totalAge</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>gopher</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>gophers</span>{
	      <span style=color:#a6e22e>totalAge</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>gopher</span>.<span style=color:#a6e22e>Age</span>
	  }
	  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>totalAge</span><span style=color:#f92672>/</span>len(<span style=color:#a6e22e>gophers</span>)
	}())
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>SequentialPattern</span>) <span style=color:#a6e22e>FetchData</span>() []<span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span> {
	<span style=color:#a6e22e>gophers</span> <span style=color:#f92672>:=</span> make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span>, <span style=color:#a6e22e>NumManipulateData</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>id</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>gophers</span> {
		<span style=color:#a6e22e>gophers</span>[<span style=color:#a6e22e>id</span>] = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Gopher</span>{}
		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Where</span>(<span style=color:#e6db74>&#34;id &gt; ?&#34;</span>, <span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>Limit</span>(<span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Find</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gophers</span>[<span style=color:#a6e22e>id</span>])
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gophers</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>sp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>SequentialPattern</span>) <span style=color:#a6e22e>Map</span>(<span style=color:#a6e22e>gophers</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>gopher</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>gophers</span> {
		<span style=color:#a6e22e>gopher</span>.<span style=color:#a6e22e>Age</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>
		<span style=color:#a6e22e>sp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Save</span>(<span style=color:#a6e22e>gopher</span>)
	}
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PipelinePattern</span>) <span style=color:#a6e22e>Execute</span>() {
	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()

	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>Map</span>(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>FetchData</span>())
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;pipeline&#34;</span>, <span style=color:#a6e22e>pp</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Elapsed:&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
	<span style=color:#a6e22e>gophers</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>Gopher</span>, <span style=color:#ae81ff>0</span>)
	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Limit</span>(<span style=color:#a6e22e>NumTotalData</span>).<span style=color:#a6e22e>Find</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gophers</span>)
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Average age(Num: %d): %d\n&#34;</span>, len(<span style=color:#a6e22e>gophers</span>), <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>int</span>{
	   <span style=color:#a6e22e>totalAge</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>gopher</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>gophers</span>{
	       <span style=color:#a6e22e>totalAge</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>gopher</span>.<span style=color:#a6e22e>Age</span>
	   }
	   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>totalAge</span><span style=color:#f92672>/</span>len(<span style=color:#a6e22e>gophers</span>)
	}())
}
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PipelinePattern</span>) <span style=color:#a6e22e>FetchData</span>() <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span> {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>id</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>id</span> &lt; <span style=color:#a6e22e>NumManipulateData</span>; <span style=color:#a6e22e>id</span><span style=color:#f92672>++</span> {
			<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gopher</span> <span style=color:#a6e22e>Gopher</span>
			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Table</span>(<span style=color:#e6db74>&#34;gophers&#34;</span>).<span style=color:#a6e22e>Where</span>(<span style=color:#e6db74>&#34;id &gt; ?&#34;</span>, <span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>Limit</span>(<span style=color:#ae81ff>1</span>).<span style=color:#a6e22e>Find</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gopher</span>)
			<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gopher</span>
		}
		close(<span style=color:#a6e22e>ch</span>)
	}()

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ch</span>
}

<span style=color:#75715e>// 고퍼들을 모두 10살 더 먹게 함.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PipelinePattern</span>) <span style=color:#a6e22e>Map</span>(<span style=color:#a6e22e>gophers</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Gopher</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gopher</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>gophers</span> {
		<span style=color:#a6e22e>gopher</span>.<span style=color:#a6e22e>Age</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>
		<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Save</span>(<span style=color:#a6e22e>gopher</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#75715e>// $ docker run -it --name mysql --rm -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=concurrency -p 3306:3306 mysql
</span><span style=color:#75715e></span>	<span style=color:#75715e>// 로 mysql 서버를 띄울 수 있다.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>mysql</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;root:root@tcp(127.0.0.1:3306)/concurrency?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&#34;</span>),
		<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gorm</span>.<span style=color:#a6e22e>Config</span>{<span style=color:#a6e22e>Logger</span>: <span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Default</span>.<span style=color:#a6e22e>LogMode</span>(<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Silent</span>)})
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
		panic(<span style=color:#e6db74>&#34;failed to connect database&#34;</span>)
	}
	<span style=color:#a6e22e>initializeDB</span>(<span style=color:#a6e22e>db</span>)

	<span style=color:#75715e>// Execute with PipelinePattern
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>func</span>() {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;==============================&#34;</span>)
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rep</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>rep</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>rep</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>pattern</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>SequentialPattern</span>{<span style=color:#a6e22e>DB</span>: <span style=color:#a6e22e>db</span>}
			<span style=color:#a6e22e>pattern</span>.<span style=color:#a6e22e>Execute</span>()
		}
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;==============================&#34;</span>)
	}()

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#e6db74>&#34;DB 부하를 가라앉히기 위해 5초간 휴식&#34;</span>)
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
	<span style=color:#75715e>// Execute with PipelinePattern
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>func</span>() {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;==============================&#34;</span>)
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rep</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>rep</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>rep</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>pattern</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>PipelinePattern</span>{<span style=color:#a6e22e>DB</span>: <span style=color:#a6e22e>db</span>}
			<span style=color:#a6e22e>pattern</span>.<span style=color:#a6e22e>Execute</span>()
		}
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;==============================&#34;</span>)
	}()
}
</code></pre></div></div></div><h3 id=-벤치마크-결과-비교>📉 벤치마크 결과 비교</h3><p><img src=line-chart-1.png alt=line-chart-1.png></p><p>Sequential하게 진행할 경우 모든 Item에 대한 Query가 완료될 때 까지 Update 작업은 <strong>지연</strong>되게 된다. 그리고 Query가 모두 완료되어야 비로소 Update 작업을 시작할 수 있게되므로 좀 더 작업 시간이 오래걸리는 편이다.</p><p>반면 <strong>Pipeline</strong>으로 진행할 경우 한 Item을 Query 하자마자 <strong>바로 바로</strong> Upadte 작업이 이루어질 수 있기때문에 작업 시간이 더 짧은 경향이 있다.</p><p>하지만 이 정도 차이는 뚜렷한 성능 차이로 보기엔 다소 미미한 것 같았다. 그래서 좀 더 IO latency가 긴 상황을 이용해봤다. DB로 localhost에서 docker mysql server를 이용하는 것이 아니라 운영 중이던 k8s cluster의 mysql pod를 kubectl port forward하여 이용해보았다. (<em>정확히는 모르지만 remote db + kubectl port forawrd 를 이용하는 경우 network latency가 아주 커져 극단적으로 좋은 예시 상황이 될 수 있을 것 같았다.</em>)</p><p><img src=line-chart-2.png alt=line-chart-2.png></p><p>위에서 가정한 remote db + port forward의 극단적 상황은 작업 진행 pattern에 따라 latency를 2배 가량 차이나게 했다.</p><p>즉 <strong>한 단계에서 오랜 시간이 소모되어 다음 단계가 지연되는 경우 Pipeline을 이용하면 좋은 것 같다</strong>. <em>이는 마치 컴퓨터 구조에서 MIPS Processor의 Pipeline을 공부할 때와 유사한 듯한 느낌을 줬다.</em></p><h2 id=마무리>마무리</h2><blockquote><p>이 글이 정확한 내용은 아닐 수 있지만 조사해본 선에서 벤치마크 해보며 작성해봤습니다. 혹시 글의 내용 중 잘못된 내용에 대한 피드백을 제시해주신다면 기회가 닿는 한 열심히 다시 알아보겠습니다~!</p></blockquote><p>평소 궁금했던 &ldquo;<em>Go의 <code>concurrent pattern</code>은 어떨 때 쓰면 좋을까?</em>&rdquo; 라는 의문 중 <code>pipeline pattern</code> 에 대해 이렇게 알아봤다.</p><p>Pipeline pattern이 CPU Bound한 작업보다는 IO latency로 인해 오랜 시간이 소모되는 작업에 더 효율적이라고 생각한 이유는 CPU Bound한 작업에서는 CPU가 이미 혹사당하고 있기 때문에 굳이 여러 goroutine을 schedule, switch하거나 channel을 통한 동기처리를 하면서 작업을 진행하기보다는 그냥 일반적인 방식으로 순차적으로 작업을 진행하는 게 좋을 수 있기 때문이다. 워낙에 얼마나 CPU bound한 작업인지, 얼마나 많은 goroutine을 이용하는지 등등 다양한 경우에 따라 달라지기 때문에 딱 잘라말할 수도 없고, 나도 많이 부족하기 때문에 정확히는 모르겠다. 하지만 추측컨대 적어도 io latency로 인해 작업들이 지연되는 경우에는 pipeline pattern이 좋은 듯하다.</p><p>추가적으로 <code>Fan-in Fan-out</code> pattern 또한 channel을 바탕으로 data를 전달하면서 작업하기 때문에 일종의 <code>Pipeline</code> pattern이 적용된 패턴인듯하여 기회가 된다면 <strong>어떤 경우에 단순히 Pipeline 패턴을 이용하는 것보다 여러 Goroutine을 이용해 작업하는 Fan-in fan out pattern이 좋을지 비교</strong>해보는 글을 적어보고싶다.</p><h2 id=참고>참고</h2><ul><li>Aidan Bae님의 Pipeline pattern에 대한 소개 - <a href=https://aidanbae.github.io/code/golang-design/pipeline/>https://aidanbae.github.io/code/golang-design/pipeline/</a></li><li>Go Blog의 Pipeline pattern에 대한 소개 - <a href=https://blog.golang.org/pipelines>https://blog.golang.org/pipelines</a></li><li>Pipeline은 ~~~ 이런 상황에 도움이 될 껄?하는 댓글 - <a href=https://www.reddit.com/r/golang/comments/7rjdw6/go_go_go_stream_processing_for_go/>https://www.reddit.com/r/golang/comments/7rjdw6/go_go_go_stream_processing_for_go/</a></li><li>Mutex와 Channel 비교 - <a href=https://github.com/golang/go/wiki/MutexOrChannel>https://github.com/golang/go/wiki/MutexOrChannel</a></li><li>Mutex와 Channel의 속도 차이 - <a href=http://www.dogfootlife.com/archives/452>http://www.dogfootlife.com/archives/452</a></li><li>Pipeline architecture를 사용하는 7가지 이유(<del>개인적으론 공감 안 감</del>) - <a href=https://labs.bawi.io/7-reasons-to-use-pipeline-architecture-93346f604b87>https://labs.bawi.io/7-reasons-to-use-pipeline-architecture-93346f604b87</a></li><li>python generator 소개, 사용법- <a href=https://wikidocs.net/16069>https://wikidocs.net/16069</a></li><li>python generator는 thread-safe하지 않다. - <a href=https://stackoverflow.com/questions/1131430/are-generators-threadsafe>https://stackoverflow.com/questions/1131430/are-generators-threadsafe</a></li></ul><footer class=footline></footer></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"umi0410"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div id=navigation><a class="nav nav-prev" href=/blog/golang/go-vs-java-oop/ title="Go vs Java - Go에서의 객체 지향"><i class="fa fa-chevron-left"></i></a><a class="nav nav-next" href=/blog/golang/go-vs-java-oop/ title="Go vs Java - Go에서의 객체 지향" style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1610376579></script><script src=/js/perfect-scrollbar.min.js?1610376579></script><script src=/js/perfect-scrollbar.jquery.min.js?1610376579></script><script src=/js/jquery.sticky.js?1610376579></script><script src=/js/featherlight.min.js?1610376579></script><script src=/js/highlight.pack.js?1610376579></script><script>hljs.initHighlightingOnLoad();</script><script src=/js/modernizr.custom-3.6.0.js?1610376579></script><script src=/js/learn.js?1610376579></script><script src=/js/hugo-learn.js?1610376579></script><script src=/mermaid/mermaid.js?1610376579></script><script>mermaid.initialize({startOnLoad:true});</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-177403492-1','auto');ga('send','pageview');}</script></body></html>