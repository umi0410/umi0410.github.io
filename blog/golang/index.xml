<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 언어 on Jinsu Playground</title><link>https://umi0410.github.io/blog/golang/</link><description>Recent content in Go 언어 on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 09 Jan 2021 11:27:30 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/blog/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go vs Java - Go에서의 객체 지향</title><link>https://umi0410.github.io/blog/golang/go-vs-java-oop/</link><pubDate>Sat, 09 Jan 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-vs-java-oop/</guid><description>시작하며 요즘 Go와 Java 모두를 이용해 개발을 하다보니 각각의 장단점에 대해 느껴볼 수 있었다. Go는 리소스를 적게 먹으며 코드가 간결하고 라이브러리나 프레임워크 또한 심플해서 적용하기 편하다. Java는 이런 저런 기능이 많은 반면 그런 기능을 이용하기 위해 이해해야하는 내용들이 많고, 코드가 투명하지는 않다(다양한 Annotation을 이용하게 되면서 코드가 투명하게 그 동작을 나타내지 않음). Java의 장점 중에서는 특히나 객체지향의 대표적인 언어답게 상속과 다형성을 능력에 따라 자유자재로 이용할 수 있다는 점이 매력적이었다.
Go 언어를 좋아하는 입장에서 개인적으로 이런 객체지향적인 특징이나 예외 처리를 제외하고는 딱히 Java가 Go에 비해 갖는 장점이 크게 느껴지지 않았다.</description></item><item><title>Go concurrency pattern - channel을 통해 간단히 세마포어처럼 동시 작업 속도 조절하기 (feat. 조회수 증가 기능)</title><link>https://umi0410.github.io/blog/golang/go-concurrency-pattern-use-case-view-count/</link><pubDate>Sat, 08 May 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-concurrency-pattern-use-case-view-count/</guid><description>시작하며 얼마 전 Channel use case 라는 Go에서의 채널 사용에 관한 글을 하나 읽었다. 한 동안 스프링 업무 보느라 잊고 지냈던 Go의 concurrency pattern이나 channel의 쓰임에 대해 다시 한 번 고민해볼 기회가 되었다. 항상 어떤 기술이 왜 좋은지, 언제 써야할지를 많이 고민하는 편이라 그 실제적인 유즈 케이스에도 굉장히 관심이 많은 편이다. 해당 글의 아쉬움은 제목은 use case였음에도 구체적인 use case라기 보다는 코드 예시 같은 느낌이 컸다.
아쉬움이 좀 있었던 터라 개인적으로 지인과 얘기해보며 고민을 좀 더 해보았다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Mutex와 Semaphore</title><link>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</link><pubDate>Wed, 20 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</guid><description>Go 언어로 적용해보는 Computer Science의 첫 번째 내용으로 OS 관련 내용 중 이론적으로는 흔하게 접할 수 있지만 실제 적용에 대한 내용은 찾아보기 힘들었던 Mutex, Semaphore에 대해 알아보려한다.
Mutex와 Semaphore은 각각의 추상적인 개념을 바탕으로 OS나 Go 등에서 사용될 수 있기에 세부적인 내용은 문맥에 따라 달라질 수 있다고 생각한다. 예를 들어 Go에서의 Mutex는 주로 sync.Mutex를 이용한 서로 다른 Goroutine의 동시 접근에 대한 제어를 의미하는 반면, 다른 프로그래밍 언어나 OS에서는 주로 서로 다른 Kernel thread나 Process에 대한 동시 접근 제어를 의미할 수 있다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Deadlock</title><link>https://umi0410.github.io/blog/golang/go-deadlock/</link><pubDate>Sun, 31 Jan 2021 18:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-deadlock/</guid><description>시작하며 개발 공부를 시작하고 여태까지 몇 년간 데드락을 실제로 접할 일은 없었다. 사실 동시성을 주의해야하는 작업을 해본 적도 없었고, 트랜잭션에 대한 개념도 없었기 때문일 수도 있다. 전공 과목에서 데드락에 대한 내용을 듣고서도 &amp;lsquo;아 이런 게 있구나&amp;rsquo; 정도로만 생각하고 넘겼었다. 하지만 Go 언어를 통해 개발을 하던 도중 Channel이나 Mutex로 인해 종종 데드락을 경험할 수 있었고, 이 경우 프로그램이 완전히 멈춰버리는 크리티컬한 문제가 발생하기도 했고, 디버깅하기 힘든 경우도 있었다. 그런 경험을 하면서 &amp;lsquo;데드락 이 녀석&amp;hellip; 만만치 않구나&amp;lsquo;라는 생각을 하곤 했다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Cache</title><link>https://umi0410.github.io/blog/golang/go-cpu-cache/</link><pubDate>Wed, 27 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-cpu-cache/</guid><description>시작하며 저번 학기에 컴퓨터 구조를 수강하면서 간과하고 있던 로우 레벨의 지식에도 흥미가 생겼었다. 그 중 CPU와 Memory, Disk의 역할에 대해 알아볼 수 있었고 캐시는 CPU와 Memory 사이에 위치해 메모리 대신 빠르게 CPU에게 데이터를 제공하는 녀석이라고 배웠다.
이전에는 주로 캐시라고 하면 주로 CDN과 같은 네트워크에서 쓰이는 캐시들밖에 몰랐다. 그렇다보니 L1 캐시, L2 캐시 같은 얘기를 들으면 OSI 7계층과 연관 지어 &amp;lsquo;음..? L2 캐시는 스위치에서 쓰는 캐시인가..?&amp;rsquo; 라는 상상을 하곤했다.
이번에는 Go를 통해 배열에 여러 차례 접근하는 프로그램을 만들어보고 벤치마킹을 통해 캐시라는 녀석이 어떤 효과를 가져다주는지 직접 확인해보려한다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Concurrency vs Parallelism</title><link>https://umi0410.github.io/blog/golang/go-concurrency-vs-parallelism/</link><pubDate>Thu, 04 Feb 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-concurrency-vs-parallelism/</guid><description>시작하며 Go 언어를 처음 배울 때 channel이나 goroutine에 대해 배우면서 Concurrency 즉 동시성으로 인해 많이 힘들었던 기억이 난다. &amp;lsquo;동시성과 병렬성이 도대체 뭐가 다르다는 것이냐..!&amp;rsquo; Rob Pike 아저씨가 동시성에 관해 했던 세미나 영상들을 보며 같이 스터디 하던 멤버들과 멘붕에 빠지기도 했고, 이런 저런 의견 교류도 했다가 며칠 지나고 보면 다시 병렬성과 헷갈리고, 제대로 된 한글 자료는 찾기 힘들었다. &amp;lsquo;동시성은 사람이 느끼기에 동시처럼 느껴지는 것이고 병렬성은 실제로 동시적인 시점에 대한 것이다.&amp;rsquo; 라는 내용이 많았지만 와닿지는 않았다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Socket (Unix Domain Socket, Network/TCP/UDP Socket)</title><link>https://umi0410.github.io/blog/golang/go-socket/</link><pubDate>Sat, 13 Feb 2021 14:10:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-socket/</guid><description>시작하며 개발 공부를 처음 시작한 지 언제 안 됐을 무렵, 의경 복무를 하며 자바로 TCP Socket을 이용해 옆 컴퓨터와 채팅을 하는 프로그램을 만들어 보는 것을 시작으로 docker나 mysql과 같은 다양한 오픈소스들을 이용해보면서나 네트워크를 공부하면서 다양하게 들어왔던 소켓이지만 정확히 어떤 역할을 하는지 어떤 종류가 있는지 어떻게 동작하는지 알지 못했다.
오늘은 그렇게 알쏭달쏭한 존재였던 소켓을 크게 Unix Domain Socket와 Network Socket 두 가지로 나눠 정리해보고 Unix Domain Socket과 TCP를 사용하는 Network Socket을 벤치마크해보고 어떤 차이가 있는지 확인해보도록 하겠다.</description></item><item><title>개발 썰 - Go Memory Leak(메모리 누수) 관련 이슈</title><link>https://umi0410.github.io/blog/golang/go-memory-leak-issue/</link><pubDate>Wed, 27 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-memory-leak-issue/</guid><description>시작하며 이 글은 Go 1.15 버전을 바탕으로 개발하며 겪은 이슈에 대해 설명하고 있으며 Go 1.16에서는 해당 이슈가 개선될 것이라고 합니다.
memory-leak-graph.png
진행 중인 쿠뮤라는 프로젝트에서 Go를 이용해 이미지에 대한 url 해싱, 리사이징, 섬네일, 센터 크롭 작업을 하는 이미지 프로세싱 마이크로서비스를 개발하고있었다. 1차적으로 어느 정도 개발이 끝난 뒤 벤치마크 겸 부하 테스트 겸해서 얼마나 해당 마이크로서비스가 잘 버티면서 작업을 수행하는지 확인해보려 했으나 Memory가 한 번 치솟게되면 어느 정도 이하로 떨어지지 않는 이슈가 발견되었다.</description></item><item><title>Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns</title><link>https://umi0410.github.io/blog/golang/go-concurrent-pattern-pipeline/</link><pubDate>Mon, 11 Jan 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-concurrent-pattern-pipeline/</guid><description>✋ 시작하며 Go를 공부하기 시작한 지도 벌써 몇 달이 지난 것 같다. 데브옵스 인턴을 마치면서 특히나 관심있었던 Go를 공부하기 시작했었고, 지난 몇 달간 AWS KRUG내의 소모임인 AUSG의 스터디 활동으로 Go를 주제로 공부해왔다. Golang의 꽃이라고 할 수 있는 요소들이 몇 개 있었는데 나는 그 중 goroutine과 channel에서 매력을 느꼈고 그를 바탕으로한 concurrency pattern들에 대해 이래 저래 많이 알아봐왔다.
하지만 concurrency pattern이 뭐고, 어떻게 사용하는지에 대해서는 여러 글을 찾아볼 수 있었지만 이게 왜 좋고 언제 쓰면 좋을지에 대한 내용은 찾아보기 힘들었다.</description></item></channel></rss>