<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 언어 on Jinsu Playground</title><link>https://umi0410.github.io/blog/golang/</link><description>Recent content in Go 언어 on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 09 Jan 2021 11:27:30 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/blog/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go concurrency pattern - channel을 통해 간단히 세마포어처럼 동시 작업 속도 조절하기 (feat. 조회수 증가 기능)</title><link>https://umi0410.github.io/blog/golang/go-concurrency-pattern-use-case-view-count/</link><pubDate>Sat, 08 May 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-concurrency-pattern-use-case-view-count/</guid><description>시작하며 얼마 전 Channel use case 라는 Go에서의 채널 사용에 관한 글을 하나 읽었다. 한 동안 스프링 업무 보느라 잊고 지냈던 Go의 concurrency pattern이나 channel의 쓰임에 대해 다시 한 번 고민해볼 기회가 되었다. 항상 어떤 기술이 왜 좋은지, 언제 써야할지를 많이 고민하는 편이라 그 실제적인 유즈 케이스에도 굉장히 관심이 많은 편이다. 해당 글의 아쉬움은 제목은 use case였음에도 구체적인 use case라기 보다는 코드 예시 같은 느낌이 컸다.
아쉬움이 좀 있었던 터라 개인적으로 지인과 얘기해보며 고민을 좀 더 해보았다.</description></item><item><title>Golang으로 백엔드 개발하기 - 5. Error Handling. 에러 잘 처리하기 (feat. fiber)</title><link>https://umi0410.github.io/blog/golang/how-to-backend-in-go-errorhandle/</link><pubDate>Sun, 05 Sep 2021 01:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/how-to-backend-in-go-errorhandle/</guid><description>시작하며 드디어 에러를 다뤄볼 차례가 됐네요. 작년까지만 해도 Error나 Exception 처리의 중요성을 잘 몰랐던 것 같습니다. 하지만 API 클라이언트랑 작업을 하면 할수록 에러 처리의 중요성을 느끼게 되는 것 같아요. 왜냐하면 백엔드에서 각각의 에러 케이스에 대한 status_code나 error_type등을 명확히 정의하지 않으면 클라이언트는 에러를 해석할 방법이 없기 때문입니다.
또한 에러를 잘 처리한 뒤 올바르게 응답하거나 로그를 남기는 것은 유지/보수 시에 백엔드 개발자 스스로 에게도 정말 중요할 수 있습니다. 우리는 실제 운영 환경의 로그를 마치 우리가 로컬에서 개발할 때 처럼 항상 보고있을 수는 없기 때문이죠.</description></item><item><title>Golang으로 백엔드 개발하기 - 4. Custom Middleware(미들웨어) 작성해보기 (feat. fiber)</title><link>https://umi0410.github.io/blog/golang/how-to-backend-in-go-middleware/</link><pubDate>Wed, 01 Sep 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/how-to-backend-in-go-middleware/</guid><description>시작하며 안녕하세요. 저번 글에서는 fiber 라는 웹 프레임워크로 간단히 웹 애플리케이션을 만드는 방법에 대해 알아봤으니 이번엔 웹 애플리케이션을 만들다보면 꼭 필요해지는 middleware 작성법에 대해 알아보겠습니다. 여태까지 백엔드에서 서버를 개발하면서는 JS의 Express 프레임워크를 제외하고는 미들웨어 개발이 그닥 쉽게 이해되는 부분은 아니었던 것 같습니다. Express에서 미들웨어를 작성하는 방법은 굉장히 직관적이고 문서도 많은 편이었거든요. 하지만 Spring은 Filter나 Interceptor를 이해하기 위해 많은 내용을 알아야하고, Django는 Class based나 function based, 그리고 middleware를 추가하는 법 등이 좀 복잡한 편이라고 생각합니다.</description></item><item><title>Golang으로 백엔드 개발하기 - 3. 웹 애플리케이션 개발해보기 (feat. fiber)</title><link>https://umi0410.github.io/blog/golang/how-to-backend-in-go-webapp/</link><pubDate>Fri, 13 Aug 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/how-to-backend-in-go-webapp/</guid><description>시작하며 이번에는 Go언어에서 유명한 웹 프레임워크를 비교해보고 간단하게 Pingpong 서버를 개발해보겠습니다. 다만 &amp;ldquo;Golang으로 백엔드 개발하기&amp;ldquo;를 주제로 글을 쓰면서 주 목적으로 했던 것은 개발하면서 계속 궁금했지만 어딘가에서 뚜렷한 설명을 찾아보기 힘들었던 내용들을 다뤄보고자하는 것이었기 때문에 이번 주제는 그닥 주 목적에 해당하는 주제는 아니므로 이번엔 아주 가~볍게 훑어보고 넘어가겠습니다. 왜냐하면 웹 프레임워크를 사용하는 것은 해당 웹프레임워크의 문서나 이런 저런 블로그들에 이미 너무도 많이 자료가 존재하기 때문입니다.
Golang으로 웹 애플리케이션을 개발하는 방법들 보통 다른 언어 같은 경우 Java에서는 Spring MVC 혹은 Spring WebFlux, Python은 FastApi, Flask, Django, Node.</description></item><item><title>Golang으로 백엔드 개발하기 - 2. 테스트 코드 작성 및 Go에서 Mocking 이용하기 (gomock, testify 이용)</title><link>https://umi0410.github.io/blog/golang/how-to-backend-in-go-testcode/</link><pubDate>Sat, 17 Jul 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/how-to-backend-in-go-testcode/</guid><description>시작하며 저는 Go 언어를 공부하면서 처음으로 테스트 코드라는 것을 접하게 되었습니다. 과거에는 그저 기능을 구현하는 것에만 관심이 있었지 애플리케이션을 어떻게 계층을 나눠 설계할지, 어떻게 해야 유지 보수하기 쉬우면서 안정적인 개발을 할 수 있을지에 대한 고민을 하지 않았습니다.
하지만 Go를 공부하면서부터는 클린 아키텍쳐나 MSA, 동시성 패턴 등을 비롯해 테스트 코드에 대해서도 공부해볼 수 있었습니다. 그 중에서도 테스트 코드에 대해 공부해보며 익혔던 점들을 바탕으로 이번 글에서는 Golang으로 백엔드 개발을 하면서 테스트 코드를 어떻게 작성할 수 있을지에 대해 알아보려합니다.</description></item><item><title>Golang으로 백엔드 개발하기 - 1. 데이터베이스 작업하기 (Ent 프레임워크 이용)</title><link>https://umi0410.github.io/blog/golang/how-to-backend-in-go-db/</link><pubDate>Sat, 03 Jul 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/how-to-backend-in-go-db/</guid><description>시작하며 Go 언어를 처음 시작한 지 벌써 1년이 지났다니 시간이 참 빠른 것 같습니다! Java는 Spring이라고하는 거대한 프레임워크가 자리 잡고 있어 딱히 어떤 프레임워크나 라이브러리를 사용할지에 대한 고민이 별로 필요 없었던 것 같습니다. 반면 Go 언어는 정형화된 아키텍쳐에 대한 내용이 별로 없고 프레임워크나 라이브러리의 대세도 참 빠르게 변하다보니 그게 장점이라면 장점이겠지만 이래저래 고생도 했네요.
게다가 Go 언어는 개발 입문자들이 많이 사용하지 않는 언어라 그런지 아직 웹 백엔드 개발에 익숙하지 않은 (저처럼) 사람들을 위한 자료들은 많이 없었던 것 같습니다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Mutex와 Semaphore</title><link>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</link><pubDate>Wed, 20 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-mutex-semaphore/</guid><description>Go 언어로 적용해보는 Computer Science의 첫 번째 내용으로 OS 관련 내용 중 이론적으로는 흔하게 접할 수 있지만 실제 적용에 대한 내용은 찾아보기 힘들었던 Mutex, Semaphore에 대해 알아보려한다.
Mutex와 Semaphore은 각각의 추상적인 개념을 바탕으로 OS나 Go 등에서 사용될 수 있기에 세부적인 내용은 문맥에 따라 달라질 수 있다고 생각한다. 예를 들어 Go에서의 Mutex는 주로 sync.Mutex를 이용한 서로 다른 Goroutine의 동시 접근에 대한 제어를 의미하는 반면, 다른 프로그래밍 언어나 OS에서는 주로 서로 다른 Kernel thread나 Process에 대한 동시 접근 제어를 의미할 수 있다.</description></item><item><title>Go vs Java - Go에서의 객체 지향</title><link>https://umi0410.github.io/blog/golang/go-vs-java-oop/</link><pubDate>Sat, 09 Jan 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-vs-java-oop/</guid><description>시작하며 요즘 Go와 Java 모두를 이용해 개발을 하다보니 각각의 장단점에 대해 느껴볼 수 있었다. Go는 리소스를 적게 먹으며 코드가 간결하고 라이브러리나 프레임워크 또한 심플해서 적용하기 편하다. Java는 이런 저런 기능이 많은 반면 그런 기능을 이용하기 위해 이해해야하는 내용들이 많고, 코드가 투명하지는 않다(다양한 Annotation을 이용하게 되면서 코드가 투명하게 그 동작을 나타내지 않음). Java의 장점 중에서는 특히나 객체지향의 대표적인 언어답게 상속과 다형성을 능력에 따라 자유자재로 이용할 수 있다는 점이 매력적이었다.
Go 언어를 좋아하는 입장에서 개인적으로 이런 객체지향적인 특징이나 예외 처리를 제외하고는 딱히 Java가 Go에 비해 갖는 장점이 크게 느껴지지 않았다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Deadlock</title><link>https://umi0410.github.io/blog/golang/go-deadlock/</link><pubDate>Sun, 31 Jan 2021 18:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-deadlock/</guid><description>시작하며 개발 공부를 시작하고 여태까지 몇 년간 데드락을 실제로 접할 일은 없었다. 사실 동시성을 주의해야하는 작업을 해본 적도 없었고, 트랜잭션에 대한 개념도 없었기 때문일 수도 있다. 전공 과목에서 데드락에 대한 내용을 듣고서도 &amp;lsquo;아 이런 게 있구나&amp;rsquo; 정도로만 생각하고 넘겼었다. 하지만 Go 언어를 통해 개발을 하던 도중 Channel이나 Mutex로 인해 종종 데드락을 경험할 수 있었고, 이 경우 프로그램이 완전히 멈춰버리는 크리티컬한 문제가 발생하기도 했고, 디버깅하기 힘든 경우도 있었다. 그런 경험을 하면서 &amp;lsquo;데드락 이 녀석&amp;hellip; 만만치 않구나&amp;lsquo;라는 생각을 하곤 했다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Cache</title><link>https://umi0410.github.io/blog/golang/go-cpu-cache/</link><pubDate>Wed, 27 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-cpu-cache/</guid><description>시작하며 저번 학기에 컴퓨터 구조를 수강하면서 간과하고 있던 로우 레벨의 지식에도 흥미가 생겼었다. 그 중 CPU와 Memory, Disk의 역할에 대해 알아볼 수 있었고 캐시는 CPU와 Memory 사이에 위치해 메모리 대신 빠르게 CPU에게 데이터를 제공하는 녀석이라고 배웠다.
이전에는 주로 캐시라고 하면 주로 CDN과 같은 네트워크에서 쓰이는 캐시들밖에 몰랐다. 그렇다보니 L1 캐시, L2 캐시 같은 얘기를 들으면 OSI 7계층과 연관 지어 &amp;lsquo;음..? L2 캐시는 스위치에서 쓰는 캐시인가..?&amp;rsquo; 라는 상상을 하곤했다.
이번에는 Go를 통해 배열에 여러 차례 접근하는 프로그램을 만들어보고 벤치마킹을 통해 캐시라는 녀석이 어떤 효과를 가져다주는지 직접 확인해보려한다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Concurrency vs Parallelism</title><link>https://umi0410.github.io/blog/golang/go-concurrency-vs-parallelism/</link><pubDate>Thu, 04 Feb 2021 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-concurrency-vs-parallelism/</guid><description>시작하며 Go 언어를 처음 배울 때 channel이나 goroutine에 대해 배우면서 Concurrency 즉 동시성으로 인해 많이 힘들었던 기억이 난다. &amp;lsquo;동시성과 병렬성이 도대체 뭐가 다르다는 것이냐..!&amp;rsquo; Rob Pike 아저씨가 동시성에 관해 했던 세미나 영상들을 보며 같이 스터디 하던 멤버들과 멘붕에 빠지기도 했고, 이런 저런 의견 교류도 했다가 며칠 지나고 보면 다시 병렬성과 헷갈리고, 제대로 된 한글 자료는 찾기 힘들었다. &amp;lsquo;동시성은 사람이 느끼기에 동시처럼 느껴지는 것이고 병렬성은 실제로 동시적인 시점에 대한 것이다.&amp;rsquo; 라는 내용이 많았지만 와닿지는 않았다.</description></item><item><title>Go 언어로 적용해보는 Computer Science - Socket (Unix Domain Socket, Network/TCP/UDP Socket)</title><link>https://umi0410.github.io/blog/golang/go-socket/</link><pubDate>Sat, 13 Feb 2021 14:10:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-socket/</guid><description>시작하며 개발 공부를 처음 시작한 지 언제 안 됐을 무렵, 의경 복무를 하며 자바로 TCP Socket을 이용해 옆 컴퓨터와 채팅을 하는 프로그램을 만들어 보는 것을 시작으로 docker나 mysql과 같은 다양한 오픈소스들을 이용해보면서나 네트워크를 공부하면서 다양하게 들어왔던 소켓이지만 정확히 어떤 역할을 하는지 어떤 종류가 있는지 어떻게 동작하는지 알지 못했다.
오늘은 그렇게 알쏭달쏭한 존재였던 소켓을 크게 Unix Domain Socket와 Network Socket 두 가지로 나눠 정리해보고 Unix Domain Socket과 TCP를 사용하는 Network Socket을 벤치마크해보고 어떤 차이가 있는지 확인해보도록 하겠다.</description></item><item><title>개발 썰 - Go Memory Leak(메모리 누수) 관련 이슈</title><link>https://umi0410.github.io/blog/golang/go-memory-leak-issue/</link><pubDate>Wed, 27 Jan 2021 15:25:54 +0900</pubDate><guid>https://umi0410.github.io/blog/golang/go-memory-leak-issue/</guid><description>시작하며 이 글은 Go 1.15 버전을 바탕으로 개발하며 겪은 이슈에 대해 설명하고 있으며 Go 1.16에서는 해당 이슈가 개선될 것이라고 합니다.
memory-leak-graph.png 진행 중인 쿠뮤라는 프로젝트에서 Go를 이용해 이미지에 대한 url 해싱, 리사이징, 섬네일, 센터 크롭 작업을 하는 이미지 프로세싱 마이크로서비스를 개발하고있었다. 1차적으로 어느 정도 개발이 끝난 뒤 벤치마크 겸 부하 테스트 겸해서 얼마나 해당 마이크로서비스가 잘 버티면서 작업을 수행하는지 확인해보려 했으나 Memory가 한 번 치솟게되면 어느 정도 이하로 떨어지지 않는 이슈가 발견되었다.</description></item></channel></rss>