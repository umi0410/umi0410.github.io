<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.80.0"><meta name=description content="Computer Science의 주요 파트 중 하나인 운영체제에서 이론적으로는 흔히 접할 수 있는 Mutex와 Semaphore가
실제로는 어떤 식으로 사용될 수 있을 지 Go 언어를 통해 직접 적용시키며 알아보았습니다."><meta name=author content="umi0410"><link rel=icon href=https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/241/whale_1f40b.png type=image/png><title>Go 언어로 적용해보는 CS - Mutex와 Semaphore :: Jinsu Playground</title><link href=/css/nucleus.css?1611125304 rel=stylesheet><link href=/css/fontawesome-all.min.css?1611125304 rel=stylesheet><link href=/css/hybrid.css?1611125304 rel=stylesheet><link href=/css/featherlight.min.css?1611125304 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1611125304 rel=stylesheet><link href=/css/auto-complete.css?1611125304 rel=stylesheet><link href=/css/atom-one-dark-reasonable.css?1611125304 rel=stylesheet><link href=/css/theme.css?1611125304 rel=stylesheet><link href=/css/hugo-theme.css?1611125304 rel=stylesheet><link href=/css/theme-umi0410-blue.css?1611125304 rel=stylesheet><link href=/css/custom-umi0410.css?1611125304 rel=stylesheet><script src=/js/jquery-3.3.1.min.js?1611125304></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}:not(pre)>code+span.copy-to-clipboard{display:none}</style></head><body data-url=/blog/golang/go-mutex-semaphore/><nav id=sidebar><div id=header-wrapper><div id=header><a id=logo href=https://umi0410.github.io><span style=font-weight:700;font-size:20px>Jinsu Playground</span></a></div><div id=profile-wrapper><style>#sidebar-profile-message{text-align:left;word-break:keep-all}p{margin-top:0;margin-bottom:0;margin-left:10px;font-size:16px}</style><a href=/><img src=/media/profile.png style=width:170px;margin-top:15px></a><div id=sidebar-profile-message><b>박진수 (umi0410)</b></br><p>Golang, Cloud services, MSA, 컨테이너와 자동화, 깔끔한 아키텍쳐에 관심이 많습니다.</p></div></div></div><div class=highlightable><ul class=topics><li data-nav-id=/portfolio/ title="About Jinsu Park (umi0410)" class=dd-item><a href=/portfolio/>Resume</a></li><li data-nav-id=/experiences/ title=Experiences class=dd-item><a href=/experiences/>Experiences</a><ul><li data-nav-id=/experiences/megazone-cloud/ title="메가존 클라우드 데브옵스 인턴 후기" class=dd-item><a href=/experiences/megazone-cloud/><b></b>Megazone Cloud DevOps</a><ul><li data-nav-id=/experiences/megazone-cloud/stargate-infra/ title="Stargate라는 인프라 구축기" class=dd-item><a href=/experiences/megazone-cloud/stargate-infra/><b></b>인프라 구축기</a></li><li data-nav-id=/experiences/megazone-cloud/ci-cd-pipeline/ title="Github Action, Spinnaker을 이용한 CI/CD 파이프라인 구축기" class=dd-item><a href=/experiences/megazone-cloud/ci-cd-pipeline/><b></b>CI/CD 파이프라인</a></li><li data-nav-id=/experiences/megazone-cloud/argo-poc/ title="Argo Project들에 대한 PoC(개념 증명) 진행" class=dd-item><a href=/experiences/megazone-cloud/argo-poc/><b></b>Argo Project PoC</a></li><li data-nav-id=/experiences/megazone-cloud/spaceone-helm/ title="SpaceONE Helm Chart 개발" class=dd-item><a href=/experiences/megazone-cloud/spaceone-helm/><b></b>Helm Chart 개발</a></li><li data-nav-id=/experiences/megazone-cloud/spacectl/ title="SpaceONE CLI Client인 spacectl 설계 및 개발" class=dd-item><a href=/experiences/megazone-cloud/spacectl/><b></b>CLI Client 설계.개발</a></li></ul></li></ul></li><li data-nav-id=/blog/ title=Blog class="dd-item
parent"><a href=/blog/>Blog</a><ul><li data-nav-id=/blog/golang/ title=Go class="dd-item
parent"><a href=/blog/golang/>Go</a><ul><li data-nav-id=/blog/golang/go-mutex-semaphore/ title="Go 언어로 적용해보는 CS - Mutex와 Semaphore" class="dd-item active"><a href=/blog/golang/go-mutex-semaphore/><b></b>Go 언어로 적용해보는 CS - Mutex와 Semaphore</a></li><li data-nav-id=/blog/golang/go-vs-java-oop/ title="Go vs Java - Go에서의 객체 지향" class=dd-item><a href=/blog/golang/go-vs-java-oop/><b></b>Go vs Java - Go에서의 객체 지향</a></li><li data-nav-id=/blog/golang/golang-concurrent-pattern-pipeline/ title="Go의 Pipeline pattern. 언제 사용해야할까? - Golang concurrent patterns" class=dd-item><a href=/blog/golang/golang-concurrent-pattern-pipeline/><b></b>Go의 Pipeline pattern. 언제 사용해야할까?</a></li></ul></li><li data-nav-id=/blog/aws/ title=AWS class=dd-item><a href=/blog/aws/>AWS</a><ul><li data-nav-id=/blog/aws/aws_eks_elb/ title="EKS K8s에서 ELB(ALB, NLB) 제대로 설정하며 사용하기" class=dd-item><a href=/blog/aws/aws_eks_elb/>EKS K8s에서 ELB(ALB, NLB) 제대로 설정하며 사용하기</a></li></ul></li></ul></li></ul><section id=shortcuts><h3>More</h3><ul><li><a class=padding href=https://github.com/umi0410><i class="fab fa-github"></i>Github</a></li></ul></section><section id=footer><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a>from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=top-github-link><a class=github-link title="Edit this page" href=https://github.com/umi0410/umi0410.github.io/edit/master/content/blog/golang/go-mutex-semaphore.md target=blank><i class="fas fa-code-branch"></i><span id=top-github-link-text>Edit this page</span></a></div><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span><span id=toc-menu><i class="fas fa-list-alt"></i></span><span class=links><a href=/>About Jinsu Park (umi0410)</a> > <a href=/blog/>Blog</a> > <a href=/blog/golang/>Go</a> > Go 언어로 적용해보는 CS - Mutex와 Semaphore</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#mutex>Mutex</a><ul><li><a href=#mutex를-이용한-go-program---counter>Mutex를 이용한 Go program - Counter</a></li><li><a href=#-mutex-그래서-언제-써요>💡 Mutex.. 그래서 언제 써요?</a></li></ul></li><li><a href=#semaphore>Semaphore</a><ul><li><a href=#mutex와-binary-semaphore의-유사한-점>Mutex와 Binary semaphore의 유사한 점</a></li><li><a href=#semaphore를-이용한-go-program-1---counter>Semaphore를 이용한 Go Program 1 - Counter</a></li><li><a href=#buffered-channel을-이용한-semaphore-in-go>Buffered channel을 이용한 Semaphore in Go</a></li><li><a href=#-semaphore-그래서-언제-쓰나요>💡 Semaphore.. 그래서 언제 쓰나요?</a></li><li><a href=#semaphore을-이용한-go-program-2---이미지-크기-변환기>Semaphore을 이용한 Go Program 2 - 이미지 크기 변환기</a></li></ul></li><li><a href=#마치며>마치며</a></li><li><a href=#참고>참고</a></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Go 언어로 적용해보는 CS - Mutex와 Semaphore</h1><p>Golang으로 실습해보는 CS의 첫 번째 내용으로 OS의 주제들 중 실습해보기 쉬운 <code>Mutex</code>, <code>Semaphore</code>, <code>DeadLock</code>에 대해 알아보려한다.</p><p>우선 Mutex, Semaphore, DeadLock은 주로 다양한 컨텍스트에서 사용되는 개념이기에 &lsquo;<em>이러한 추상적인 개념을 갖고있구나!</em>&rsquo; 정도로 이해하면 될 것이고, 정확한 그 구현은 컨텍스트(e.g. 데이터베이스에 대한 건지 OS에 대한 건지 Go에 대한 건지)에 따라 달라질 수 있다고 생각한다. 예를 들어 Go에서의 Mutex는 주로 <code>sync.Mutex</code>를 이용한 서로 다른 Goroutine의 동시 접근에 대한 제어를 의미할 것이고, 다른 일반적인 프로그래밍 언어나 OS에서는 서로 다른 Thread나 Process에 대한 동시 접근 제어가 될 수 있을 수 있을 것 같다.</p><h2 id=mutex>Mutex</h2><p><code>Mutex</code>는 <strong>Mutual Exclusion</strong>의 줄임말로 <strong>상호 배제</strong>를 의미한다. 즉 <strong>서로 다른 워커가 공유 자원에 접근하는 것을 제한</strong>한다는 말이다. <code>Go</code>에서는 이 &ldquo;<strong>워커</strong>&ldquo;가 <code>Goroutine</code>이 되고, 컨텍스트에 따라 프로세스가 될 수도, 스레드가 될 수도 그 외의 다른 존재가 될 수도 있다. <code>공유 자원</code>이란 여러 워커가 동시에 접근하는 자원을 말하고 이 <strong>공유 자원에 대한 동시 접근을 제한해 thread-safe하게 작업하고자 하는 영역</strong>을 <code>Critical section</code>이라고 한다. Cricical section은 Mutex가 Lock을 수행한 뒤 Unlock되기 전까지의 영역이며, Lock과 Unlock은 Atomic한 작업이기때문에 어떠한 경우에도 동시적으로 수행될 수 없다.</p><p><img src=mutex-1.png alt=mutex-1.png></p><p>이해하기 쉽게 예시를 통해 접근해보겠다. 원래 화장실 예제를 보고 굉장히 와닿았는데, 화장실보다는 피팅룸이 좀 더 청결한 것 같아서 피팅룸으로 예를 들어보겠다. 우리 귀여운 고퍼가 <strong>피팅룸을 한 개만 운영하는 옷가게에 방문</strong>했다고 가정해보자.</p><p><img src=mutex-2.png alt=mutex-2.png></p><ul><li>피팅룸 - Critical section</li><li>고퍼가 피팅룸에 들어가서 옷을 입는 작업은 하나의 Goroutine</li></ul><p>동시에 여러 고퍼가 하나의 피팅룸에서 옷을 갈아입으려한다면 😟 난처한 상황이 발생할 것이다. 그렇기때문에 피팅룸에는 Lock, Unlock 기능이 존재해야하는데, 이 기능을 구현한다해도 <strong>Atomic</strong>하게 동작할 수 있도록 제대로 구현하지 않는다면 <strong>한 워커가 Lock을 하는 사이에 다른 워커가 동시에 Lock</strong>을 걸려할 수 있고, 그 경우 두 워커가 동시에 한 피팅룸(Critical Section)에서 작업을 하려할 것이다. 그렇기때문에 <strong>Lock, Unlock은 Atomic해야하며 이렇게 각 워커를 상호 배제시켜 동시에 작업할 수 없도록 하는 것</strong>이 바로 <code>Mutex</code>이다.</p><h3 id=mutex를-이용한-go-program---counter>Mutex를 이용한 Go program - Counter</h3><p><strong>Count = 0에서 시작해 동시적으로 +1을 10만 번, -1을 10만 번 수행하는 카운터 프로그램</strong></p><p>그럼 실생활에 비유한 Mutex는 이 정도로 마치고, Mutex가 어떻게 사용되는지 Go로 짠 간단한 Counter 프로그램을 통해 알아보자.</p><ul><li>Mutex를 잘 적용한 경우 - 몇 번을 수행하든 결과는 0.</li><li>Mutex가 적용되지 않은 safe하지 않은 경우 - 결과가 0이 나오지 않을 수 있다.</li></ul><p>특히 <code>Go</code>에서는 <code>sync</code> 패키지의 <code>Mutex</code>라는 type을 통해 간단하게 Mutex 기능을 이용할 수 있다. <strong>동일한 Mutex struct를 참조한다면 같은 Key를 이용한다는 개념</strong>이고, <code>mutex.Lock()</code>을 호출한 뒤 <code>mutex.Unlock()</code>이 호출되기 이전까지가 Critical section이 되며 다른 goroutine들은 같은 Mutex(즉 키)에 의한 Critical section에 진입할 수 없다.</p><p><em>내가 처음 Mutex를 처음 접했을 때 한 가지 헷갈렸던 것</em>은 당시 Critical section이라는 개념이 없었기 때문에 Lock을 호출하기만 하면 런타임에 <del>알아서 스마트하게 Lock과 Unlock사이의 변수들에 대한 접근 중 동시적인 접근만을 잠시 블락해주는 줄</del> 알았는데, 사실 그 사이 변수들중 동시적으로 접근하려는 변수에 대해서만 잠시 블락해주는 게 아니라 <strong>Lock과 Unlock 사이를 Critical section으로 만드는 것</strong>이었다.</p><p>자 그럼 Count라는 하나의 int형 변수에 동시적으로 접근을 하는 상황을 극대화하기 위해 여러 고루틴으로 작업해보겠다. +1을 1만 번하는 고루틴을 10개, -1을 1만 번하는 고루틴을 마찬가지로 10개 이용하겠다.</p><p>전체 코드 참고: <a href=https://play.golang.org/p/xaLE1YkAdvd>https://play.golang.org/p/xaLE1YkAdvd</a></p><p><img src=output-1.png alt=output-1.png></p><ul><li>우리가 일반적으로 익숙한 Sync 즉 동기적인 순차적 진행 시에는 당연히 10만번 +1, 10만번 -1 후에 결과가 0이었다.</li><li>동시적 접근을 수행하자 10만번 +1, 10만번 -1을 했지만 <code>Count += 1</code> 을 수행하던 중 또 다른 <code>Count += 1</code>이 수행되는 등의 원치않던 상황이 야기될 수 있기에 결과값이 0인 경우를 찾기 힘들다.</li><li>여러 Goroutine을 이용해 concurrent하게 작업을 수행하도록하며 <code>Count += 1</code>, <code>Count -= 1</code> 과 같은 <strong>동시적 접근이 수행되어서는 안되는 영역은 Critical Area</strong>로 설정하기 위해 그 전 후에 <code>sync.Mutex</code>를 이용해 Lock, Unlock 기능을 넣어주자 <strong>원했던 대로 0의 결과</strong>를 얻을 수 있었다.</li></ul><h3 id=-mutex-그래서-언제-써요>💡 Mutex.. 그래서 언제 써요?</h3><p>사실 Mutex라는 개념이 그렇게 어려운 것도 아니고, 사용법 자체가 어려운 것도 아니다. 나는 하지만 항상 <strong>&ldquo;언제&rdquo;</strong>, <strong>&ldquo;왜&rdquo;</strong> 써야하는지를 궁금해하는 편이다.</p><ol><li>Critical section에서 많은 시간이 소요되는 경우? ⇒ ❌
위의 counter와 같은 작업은 대부분의 작업이 critical section 속에 있다고 볼 수 있다. 이 경우 동시적인 작업과 함께 Lock, Unlock을 하며 critical section을 관리하는 것보다 애초에 작업 자체를 동기적으로 수행하는 게 나을 수 있다. 왜냐하면 동시적 작업 속에서 Mutex를 통해 동기적으로 작업할 수 있도록 하는 것에서 오는 오버헤드는 분명히 존재하고, Critical section 밖에서 효율적으로 동시적으로 작업을 진행했다하더라도 critical section에서 병목이 발생해버려 전체적인 Throughput이 안 좋아질 것이다.</li><li><strong>Critical section에서는 적은 시간이 소요되고, 대부분은 동시적으로 작업이 가능한 경우</strong>? ⇒ ⭕
예를 들어 어떤 API를 여러 번 호출한 뒤 그 응답 중 일부를 계속해서 더해 결과를 내는 Reduce 작업을 수행한다고 치자. 순차적으로 수행할 시 오랜 시간이 소요될 API 호출은 동시적으로 진행하고, 결과에 대한 Reduce 작업만 잠시 Critical section내에서 작업한다면 아주 좋은 성능과 함께 안전하게 작업할 수 있을 것이다!</li></ol><h2 id=semaphore>Semaphore</h2><p><img src=semaphore.png alt=semaphore.png></p><p>Mutex에서 대부분의 Lock이나 Critical section에 대한 내용을 설명했기 때문에 Semaphore에서 더 설명할 내용이 많지는 않다. Semaphore의 동작에 대한 간단한 예시는 위의 그림과 같은데, 5마리의 고퍼가 존재한다해도 동시에 접근할 수 있게하는 고퍼를 3개로 제한한다면 2마리의 고퍼는 피팅룸에 들어가지 못하고 블락된다. Locked와 Unlocked 상태 뿐인 <code>Mutex</code>와 달리 <code>Semaphore</code>는 <strong>임의의 개수를 세는 Counter처럼 동작해 임의의 개수의 워커만이 Critical section에 동시적으로 접근</strong>할 수 있도록 한다.</p><p>Counter를 예로 들자면 10개의 워커가 존재한다해도 &ldquo;5"를 세는 Semaphore는 한 워커가 Critical section에 진입할 때마다 Counter 값을 1씩 낮추고, Critical section을 탈출할 때마다 Counter 값을 다시 1씩 높인다. 만약 어떤 워커가 Critical section에 진입하려는데 Count 값이 0이라면 초기에 계획했던 대로 5개의 워커가 이미 동시적으로 작업중이라는 의미이므로 이 워커는 한 워커가 Critical section을 나오면서 Counter 값을 다시 1 증가시킬 때까지 Block된다.</p><p>Mutex의 Lock과 Unlock이 Atomic하기에 어떠한 경우에도 동시적으로 수행될 수 없었듯이 Semaphore의 Counting 작업 또한 Atomic해야하고 그래야만 Thread-safe한 counter로 동작할 수 있다. Semaphore가 수행하는 Counting 작업은 주로 try를 뜻하는 네덜란드어 Proberen의 앞 글자를 딴 <code>P</code>와 increment를 뜻하는 Verhogen의 앞 글자를 딴 <code>V</code>로 두 가지가 표현하는 듯하다. <code>P</code>는 Count 값이 0이 아니면 작업을 수행하겠다는 의미하며 만약 Count 값이 0이라면 0이 아닌 값이 될 때까지 wait했다가 0 아닌 값이 되면 count 값을 1 감소시키며 작업을 시작한다. <code>V</code>는 작업을 마치며 count 값을 다시 1 증가시키겠다는 의미이다.</p><h3 id=mutex와-binary-semaphore의-유사한-점>Mutex와 Binary semaphore의 유사한 점</h3><p>동시 접근 워커를 1개로 제한하는 Semaphore의 경우 Count 값이 0과 1 두 개로만 존재할 수 있는데 이를 Binary semaphore라고한다. 특히 이는 Locked와 Unlocked라는 두 가지의 상태만을 갖는 Mutex와 유사하다. 하지만 Binary semaphore는 mutex가 유사한 기능을 할 뿐 동일하지는 않다는 의견이 많다. 그 이유는 <strong>Mutex는 Lock 방식을 이용하고 Semaphore는 Signal(신호) 방식을 이용</strong>하기 때문이다. Lock 방식의 경우 Lock을 수행한 워커만이 Unlock을 할 수 있는 반면 Signal 방식은 try(작업 시도)를 수행한 워커가 아니더라도 increment(작업 완료) 신호를 보낼 수 있기에 서로 명백히 동작 방식이 다르다는 것이다. (하지만 이 부분에 대해서는 직접 실습해보지는 못했다.)</p><p>*Semaphore를 이해하는 데에 있어 내가 착각해서 헤맸던 부분은 바로 <del>Semaphore의 요점이 thread-safe한 count라고 착각</del>*했던 것이다. 하지만 semaphore의 요점은 여러 워커에 대해서 thread safe한 count 기능을 제공하는 것이 아니라 임의의 숫자만큼의 동시적 접근을 허용하고, 그 이상은 Block 상태로 대기시킨다는 것이다.</p><h3 id=semaphore를-이용한-go-program-1---counter>Semaphore를 이용한 Go Program 1 - Counter</h3><p>go에서 Semaphore를 이용하는 방법은 크게 2가지가 있는 것 같다. 아래 두 가지 방법 중 좀 더 Go스러운 <code>channel</code>을 이용해보겠다.</p><ol><li>Go 특유의 자료형인 <code>channel</code>을 이용하기 - channel은 여러 goroutine의 concurrent한 작업간 데이터 전송은 물론이고 동시적인 작업 중 데이터를 편리하게 동기화해주는 녀석이다. 따라서 동기적인 count와 유사한 기능을 내재하고있다.</li><li><a href=http://golang.org/x/sync/semaphore>golang.org/x/sync/semaphore</a>의 Weighted를 이용하기 - Semaphore의 P를 Acquire, V를 Release로 구현해 이용할 수 있게 했다.</li></ol><p>전체 코드는 Mutex와 동일하며 마찬가지로 다음 링크로 참고해볼 수 있다: <a href=https://play.golang.org/p/xaLE1YkAdvd>https://play.golang.org/p/xaLE1YkAdvd</a></p><h3 id=buffered-channel을-이용한-semaphore-in-go>Buffered channel을 이용한 Semaphore in Go</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DoSemaphore</span>(<span style=color:#a6e22e>maxConcurrent</span> <span style=color:#66d9ef>int64</span>){
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
        <span style=color:#a6e22e>Count</span> = <span style=color:#ae81ff>0</span>
        <span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
        <span style=color:#a6e22e>sem</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#a6e22e>maxConcurrent</span>)
        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>20</span>)
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
            <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Add1Sem</span>(<span style=color:#a6e22e>wg</span>, <span style=color:#a6e22e>sem</span>)
            <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Sub1Sem</span>(<span style=color:#a6e22e>wg</span>, <span style=color:#a6e22e>sem</span>)
        }
        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Concurrent goroutines + Semaphore&#34;</span>, <span style=color:#a6e22e>maxConcurrent</span>, <span style=color:#e6db74>&#34;Result(Desired 0):&#34;</span>, <span style=color:#a6e22e>Count</span>, <span style=color:#e6db74>&#34;&#34;</span>)
    }

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;=====================================&#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sub1Sem</span>(<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>, <span style=color:#a6e22e>sem</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}){
    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>{
        <span style=color:#a6e22e>sem</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>struct</span>{}{}
        <span style=color:#a6e22e>Count</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
        <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>sem</span>
    }
}
</code></pre></div><p>channel을 이용한 Semaphore 코드를 설명하기 위해 전체 코드 중 일부를 가져와보았다. Semaphore를 이용하기 위해 <code>Unbuffered channel</code>이 아닌 <code>Buffered channel</code>을 이용하는 이유는 다음과 같은 Unbuffered channel의 동작 방식이 Semaphore의 동작 방식과 동일하기 때문이다.</p><ul><li>Buffer의 크기만큼은 동시적으로 channel에 값을 넣으려는 시도가 허용됨.</li><li>buffered channel이 꽉 찬 경우 채널에서 값을 꺼내지 않는 이상은 추가적으로 Channel에 값을 넣으려시도하는 goroutine은 Block됨.</li></ul><p><img src=output-2.png alt=output-2.png></p><p>(앞서 코드를 링크한 go playground에서 코드를 바로 실행해볼 수 있다.)</p><p>동시 접근 워커를 1개로 제한하는 Semaphore는 <strong>Binary Semaphore로서 Mutex를 이용했을 때와 유사하다고 말했듯이 thread-safe하게 count 작업이 이루어져 예상되는 값이었던 0이 출력됨</strong>을 확인할 수 있다. 하지만 동시접근이 가능한 워커가 1개 이상이 되면 thread-safe하지 않게 되고, 동시접근 워커 개수가 많아질수록 결과가 더 부정확한 경향이 있는 것으로 나타났다.</p><h3 id=-semaphore-그래서-언제-쓰나요>💡 Semaphore.. 그래서 언제 쓰나요?</h3><blockquote><p>Semaphore 개념은 알겠는데, Mutex는 Thread safe하게 작업하려는 경우 사용하려는 건 알겠습니다. 근데 그럼 mutex나 쓰면 되지 일정 개수만큼만 동시접근을 허용하려는 경우가 있을까요?</p></blockquote><p>Semaphore을 사용하기 좋은 케이스는 <strong>동시에 접근할 수 있는 워커 수를 제한하는 경우</strong>이고, 이는 주로 <strong>CPU Bound한 작업을 수행하거나 Memory 점유율을 낮추고자하는 경우</strong>에 이용된다. 이러한 케이스는 Go의 Worker pool 패턴을 이용하는 경우나 Pipeline pattern을 이용하는 경우와 유사하다.(<em>처음엔 Go의 모든 Concurrent pattern들을 개별적으로 구별지으려했었는데, 공부하다보니 일정한 개수의 Worker를 이용하는 Worker Pool pattern, Channel을 기반으로 작업 내역을 쪼개어 실시간 처리하는 Pipeline, 한 채널, 여러 Goroutine을 이용하는 Fan-in Fan-out pattern 등등 다들 유사하고 연관이 되어있더라.</em>)</p><p><strong>Semaphore로 동시 접근 Worker 수를 제한하지 않고 모든 Goroutine을 동시적으로 수행하는 경우엔 어떻게 될까?</strong></p><p>Logical Processor 개수를 훨씬 넘는 모든 Goroutine 동시적으로 작업을 진행할 경우 아무리 Goroutine이 concurrent한 작업 수행에 뛰어난 성능을 보인다할지라도 과하게 많은 수의 Goroutine은 성능 저하를 야기하지 않을까 예상했다. 하지만 user-level thread 혹은 green level thread의 일종인 Goroutine은 OS(혹은 Kernel) thread와 달리 Context switch로 인한 penalty가 거의 없어서인지 거의 Throughput 면에서의 성능 차이가 없었다.</p><blockquote><p>참고: Kernel level thread는 주로 Preemptive한 schedule을, User level thread는 주로 Cooperative한 schedule 방식을 이용하지만 Goroutine은 User level thread임에도 Go 1.14 버전부터는 10ns를 기준으로 asynchronously preemptive한 schedule 방식도 사용하고 있다고 한다. goroutine간의 cooperative한 스케쥴링 preemptive한 스케쥴링 방식 모두를 지원하고 있는 게 아닐까 싶은데, Go 1.14가 릴리즈된 지 얼마되지 않았기도 하고, 이에 대해서는 명확히 설명된 문서를 찾기 힘들었다.
User level thread의 예로는 RxJava in Java, Coroutine in Kotlin, Goroutine in Golang이 있고, 이들은 Cooperative하게 schedule하기 때문에 context switch시의 penalty가 매우 적다.</p></blockquote><p>하지만 Throughput 적인 측면보다는 Machine의 Resource 소모 측면에서는 모든 Goroutine이 동시적으로 수행되는 구조보다는 <strong>Semaphore을 바탕으로한 동시에 일정 개수의 워커만이 작업하는 Worker Pool 구조가 훨씬 Memory나 CPU 리소스를 적게 소모</strong>하는 듯 했다. 또한 100개의 동시 요청을 수행하는데 동일한 Throughput으로 약 10초가 걸린다고 치면, 요청당 goroutine을 생성하는 경우는 첫 번째 요청도 거의 10초가 걸린 반면 Semaphore을 이용한 경우는 먼저 온 요청은 대체로 빠르게 먼저 처리되는 경향을 보였다. 이 차이는 <strong>처음 요청을 보낸 사용자 마저 10초를 기다리게 할 것이냐, 0.1초만에 응답을 받도록 할 것이냐의 차이</strong>이다. 또한 <strong>전체 작업이 늘어지면 그 작업에 대한 메모리 점유가 지속</strong>되기에 메모리 측면에서도 비효율적이다.</p><h3 id=semaphore을-이용한-go-program-2---이미지-크기-변환기>Semaphore을 이용한 Go Program 2 - 이미지 크기 변환기</h3><p>마침 이번에 프로젝트에서 thumbnail 생성, image 크기 변환, hashed uri 생성 작업 등을 담당하는 <code>image processing 서버</code>를 개발하려했는데, image를 불러오는 I/O 작업 이후의 image processing은 CPU Bound 한 작업이기 때문에 동시적으로 동작하는 Goroutine이 일정 숫자(대게 Logical Processor 개수) 이상으로는 많아져봤자 크게 효율이 없을 것이라 예상했고, 그와 관련해 간단하게 이미지 크기 변환 프로그램을 하나 만들어 테스트 해보았다.</p><p>약 2MB의 이미지에 대한 크기 변환 작업 요청이 동시에 30개 들어왔다는 가정을 했고, semaphore을 이용한 경우 동시적으로 최대 4개의 worker(goroutine)이 작업을 수행할 수 있게, concurrent를 이용한 경우는 30개의 요청 모두 동시적으로 작업을 하는 경우이다.</p><p>(코드 참고(인터넷 액세스를 하는 경우 Playground에서 동작하지는 않는듯하다): <a href=https://play.golang.org/p/Vfyw6uCOIuL>https://play.golang.org/p/Vfyw6uCOIuL</a>)</p><blockquote><p>사실 Logical Processor 8개, RAM 16GB의 개인 노트북으로는 그 차이가 많이 나지는 않아서 AWS EC2 t2.micro instance에서 성능을 테스트해봤다.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ubuntu</span><span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>ip</span><span style=color:#f92672>-</span><span style=color:#ae81ff>172</span><span style=color:#f92672>-</span><span style=color:#ae81ff>31</span><span style=color:#f92672>-</span><span style=color:#ae81ff>12</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>:<span style=color:#960050;background-color:#1e0010>~$</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>sem</span> <span style=color:#a6e22e>semaphore</span>
<span style=color:#a6e22e>변환하고자하는</span> <span style=color:#a6e22e>Image들을</span> <span style=color:#a6e22e>메모리에</span> <span style=color:#a6e22e>Load했습니다</span>.
<span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>01</span><span style=color:#f92672>/</span><span style=color:#ae81ff>18</span> <span style=color:#ae81ff>20</span>:<span style=color:#ae81ff>28</span>:<span style=color:#ae81ff>13</span> <span style=color:#a6e22e>Elapsed</span>: <span style=color:#ae81ff>1.974380959</span><span style=color:#a6e22e>s</span>
<span style=color:#f92672>...</span> <span style=color:#a6e22e>생략</span>
<span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>01</span><span style=color:#f92672>/</span><span style=color:#ae81ff>18</span> <span style=color:#ae81ff>20</span>:<span style=color:#ae81ff>28</span>:<span style=color:#ae81ff>26</span> <span style=color:#a6e22e>Elapsed</span>: <span style=color:#ae81ff>1.159552779</span><span style=color:#a6e22e>s</span>
<span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>01</span><span style=color:#f92672>/</span><span style=color:#ae81ff>18</span> <span style=color:#ae81ff>20</span>:<span style=color:#ae81ff>28</span>:<span style=color:#ae81ff>26</span> <span style=color:#a6e22e>Elapsed</span>: <span style=color:#ae81ff>1.016627316</span><span style=color:#a6e22e>s</span>
<span style=color:#ae81ff>2021</span><span style=color:#f92672>/</span><span style=color:#ae81ff>01</span><span style=color:#f92672>/</span><span style=color:#ae81ff>18</span> <span style=color:#ae81ff>20</span>:<span style=color:#ae81ff>28</span>:<span style=color:#ae81ff>26</span> <span style=color:#a6e22e>Total</span> <span style=color:#a6e22e>elapsed</span>: <span style=color:#ae81ff>14.959516003</span><span style=color:#a6e22e>s</span>

<span style=color:#a6e22e>ubuntu</span><span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>ip</span><span style=color:#f92672>-</span><span style=color:#ae81ff>172</span><span style=color:#f92672>-</span><span style=color:#ae81ff>31</span><span style=color:#f92672>-</span><span style=color:#ae81ff>12</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>:<span style=color:#960050;background-color:#1e0010>~$</span> .<span style=color:#f92672>/</span><span style=color:#a6e22e>sem</span> <span style=color:#a6e22e>concurrent</span>
<span style=color:#a6e22e>변환하고자하는</span> <span style=color:#a6e22e>Image들을</span> <span style=color:#a6e22e>메모리에</span> <span style=color:#a6e22e>Load했습니다</span>.
<span style=color:#a6e22e>Killed</span>
</code></pre></div><p>놀랍게도 동시적으로 30개의 요청을 보내는 경우에 30개의 모든 goroutine이 동시에 작업을 시도할 때에는 과도한 리소스 사용으로 인해 아예 OS가 프로세스를 Kill해버렸다. 즉 <strong>Semaphore로 동시 접근 Worker 수를 제한하지 않는 경우 t2.micro 인스턴스로 돌리는 image 서버에 동시에 30개의 image resizing 요청이 들어오면 process가 죽어버린다</strong>는 말이다&mldr;!</p><p>또한 앞서 말했듯이 동시에 요청하는 사용자가 많아지더라도 Semaphore을 이용한 경우는 나중에 들어온 요청일 수록 처리가 늘어지지만, Semaphore를 통해 동시 작업을 제한하지 않는 경우는 전체 작업이 늘어진다.</p><p>이렇게 Semaphore는 동시 접근 워커 수를 제한하여 전체적인 Throughput 측면보다는 리소스 소모적인 측면과 먼저 처리될 수 있는 작업은 먼저 처리되도록 할 수 있다는 면에서 장점이 있음을 확인할 수 있었다.</p><h2 id=마치며>마치며</h2><p>Mutex나 Semaphore의 개념이나 설명과 같은 이론적인 내용은 구글링을 통해 어렵지 않게 얻을 수 있는 흔한 지식인 반면, 정확히 언제 쓰면 좋을지, 언제 쓰일 수 있을지와 같은 실용적인 내용은 찾아보기 어려웠기때문에 Go를 통해 Mutex와 Semaphore을 이용해보는 간단한 프로그램을 만들어 실습해보았다.</p><p>예제 프로그램으로서 코드를 간결하고 읽기 쉽게 깔끔하게 제공해보고자했는데, 그러기 쉽지 않았던 것 같아 아쉽다. 다음엔 기회가 되면 go의 benchmark test를 이용해보면 어떨까싶다.</p><h2 id=참고>참고</h2><p><strong>Goroutine과 Goroutine scheduling에 대해</strong> - <a href=https://thegopher.tistory.com/3>https://thegopher.tistory.com/3</a></p><p>화장실에 비유한 뮤텍스와 세마포어 - <a href=https://worthpreading.tistory.com/90>https://worthpreading.tistory.com/90</a></p><p>semaphore in Go <a href=https://medium.com/@deckarep/gos-extended-concurrency-semaphores-part-1-5eeabfa351ce>https://medium.com/@deckarep/gos-extended-concurrency-semaphores-part-1-5eeabfa351ce</a></p><p>cooperative vs preemptive - <a href=https://medium.com/traveloka-engineering/cooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe>https://medium.com/traveloka-engineering/cooperative-vs-preemptive-a-quest-to-maximize-concurrency-power-3b10c5a920fe</a></p><p>preemptive scheduling in go - <a href=https://blog.puppyloper.com/menus/Golang/articles/Goroutine%EA%B3%BC%20Go%20scheduler>https://blog.puppyloper.com/menus/Golang/articles/Goroutine과 Go scheduler</a></p><footer class=footline></footer></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"umi0410"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div id=navigation><a class="nav nav-prev" href=/blog/golang/ title=Go><i class="fa fa-chevron-left"></i></a><a class="nav nav-next" href=/blog/golang/go-vs-java-oop/ title="Go vs Java - Go에서의 객체 지향" style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1611125304></script><script src=/js/perfect-scrollbar.min.js?1611125304></script><script src=/js/perfect-scrollbar.jquery.min.js?1611125304></script><script src=/js/jquery.sticky.js?1611125304></script><script src=/js/featherlight.min.js?1611125304></script><script src=/js/highlight.pack.js?1611125304></script><script>hljs.initHighlightingOnLoad();</script><script src=/js/modernizr.custom-3.6.0.js?1611125304></script><script src=/js/learn.js?1611125304></script><script src=/js/hugo-learn.js?1611125304></script><script src=/mermaid/mermaid.js?1611125304></script><script>mermaid.initialize({startOnLoad:true});</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-177403492-1','auto');ga('send','pageview');}</script></body></html>