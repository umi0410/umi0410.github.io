<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="백엔드 개발을 하며 흔히 겪을 수 있는 N+1 문제나 비효율적 쿼리 문제, 그 중에서도 조회수와 같은 Count 성격의 작업을 Redis를 이용해 어떻게 최적화할 수 있을지 다뤄보았습니다.
"><title>쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)</title><link rel=canonical href=https://umi0410.github.io/blog/optimizing-count-query-strategy/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)"><meta property="og:description" content="백엔드 개발을 하며 흔히 겪을 수 있는 N+1 문제나 비효율적 쿼리 문제, 그 중에서도 조회수와 같은 Count 성격의 작업을 Redis를 이용해 어떻게 최적화할 수 있을지 다뤄보았습니다.
"><meta property="og:url" content="https://umi0410.github.io/blog/optimizing-count-query-strategy/"><meta property="og:site_name" content="Jinsu Playground"><meta property="og:type" content="article"><meta property="article:section" content="Blog"><meta property="article:published_time" content="2021-11-24T03:46:54+09:00"><meta property="article:modified_time" content="2021-11-24T03:46:54+09:00"><meta property="og:image" content="https://umi0410.github.io/blog/optimizing-count-query-strategy/index.png"><meta name=twitter:title content="쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)"><meta name=twitter:description content="백엔드 개발을 하며 흔히 겪을 수 있는 N+1 문제나 비효율적 쿼리 문제, 그 중에서도 조회수와 같은 Count 성격의 작업을 Redis를 이용해 어떻게 최적화할 수 있을지 다뤄보았습니다.
"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://umi0410.github.io/blog/optimizing-count-query-strategy/index.png"><link rel="shortcut icon" href=https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/241/whale_1f40b.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177403492-1","auto"),ga("send","pageview"))</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=East+Sea+Dokdo&family=Noto+Sans+KR:wght@400&display=swap" rel=stylesheet><style>@import 'https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css';:root{--body-background:#fafeff;--base-font-family:Pretendard, 'Noto Sans KR', sans-serif}.site-name{--site-name-font-family:'East Sea Dokdo', cursive;font-family:var(--site-name-font-family);font-size:3.2rem!important}.left-sidebar{--sidebar-avatar-size:200px}figure.site-avatar{margin-left:auto!important;margin-right:auto!important}</style></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://umi0410.github.io class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/optimizing-count-query-strategy/><img src=/blog/optimizing-count-query-strategy/index_hu2e0266c55b356006b8efd84bbe6e386e_394889_800x0_resize_box_3.png srcset="/blog/optimizing-count-query-strategy/index_hu2e0266c55b356006b8efd84bbe6e386e_394889_800x0_resize_box_3.png 800w, /blog/optimizing-count-query-strategy/index_hu2e0266c55b356006b8efd84bbe6e386e_394889_1600x0_resize_box_3.png 1600w" width=800 height=752 loading=lazy alt="Featured image of post 쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)"></a></div><div class=article-details><header class=article-category><a href=/categories/golang/>Golang (Go 언어)</a>
<a href=/categories/spring/>Spring (스프링)</a>
<a href=/categories/jpa/>JPA</a></header><h2 class=article-title><a href=/blog/optimizing-count-query-strategy/>쿼리 최적화하기 - 조회수와 같은 Count 성격의 작업 최적화하기 (N+1 문제 관련, feat. Redis)</a></h2><h3 class=article-subtitle>백엔드 개발을 하며 흔히 겪을 수 있는 N+1 문제나 비효율적 쿼리 문제, 그 중에서도 조회수와 같은 Count 성격의 작업을 Redis를 이용해 어떻게 최적화할 수 있을지 다뤄보았습니다.</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Nov 24, 2021</time></footer></div></header><section class=article-content><h2 id=시작하며>시작하며</h2><p><figure style=flex-grow:231;flex-basis:555px><a href=/blog/optimizing-count-query-strategy/monitoring.png data-size=1012x437><img src=/blog/optimizing-count-query-strategy/monitoring.png srcset="/blog/optimizing-count-query-strategy/monitoring_hu3985549258cc81ebaf9b1ddb4dd53245_70044_480x0_resize_box_3.png 480w, /blog/optimizing-count-query-strategy/monitoring_hu3985549258cc81ebaf9b1ddb4dd53245_70044_1024x0_resize_box_3.png 1024w" width=1012 height=437 loading=lazy alt="Sentry monitoring - 느려진 API Latency"></a><figcaption>Sentry monitoring - 느려진 API Latency</figcaption></figure></p><p><strong>짧은 영상을 바탕으로 배틀을 할 수 있는 서비스를 <code>Spring Boot MVC</code> + <code>JPA</code>로 개발</strong>하던 중 위와 같이 API <strong>Latency가 처참하게도 느린 요청</strong>들이 감지되기 시작했습니다. 그동안은 쿼리 최적화보다는 로직 개발이 더 우선시하다보니 쿼리 최적화를 미뤄왔는데,
이번 기회에 이에 대해 다뤄보려합니다. 간단하게 코드를 짜서 테스트해보느라 Go 언어를 이용했지만 <strong>JPA를 이용하든 뭘 이용하든 문제와 그에 대한 해결책의 요지는 동일할 것</strong>입니다.</p><p>아무래도 백엔드에서 API를 개발하면서 파일 데이터를 주고 받는 게 아니라면 주로 Latency가 늘어나는 이유는 다음과 같을 것입니다.</p><ul><li>너무 많은 Write</li><li>불필요한 Column(필드) 혹은 관계를 Eager Loading. 추가적으로 경우에 따라 <strong>N+1 쿼리 문제</strong> 발생</li><li>필요한 Column(필드) 혹은 관계를 뒤늦게 Lazy Loading. 추가적으로 경우에 따라 <strong>N+1 쿼리 문제</strong> 발생</li><li><strong>요청마다 매번 수행되는 Join이나 일종의 연산들</strong></li></ul><blockquote><p><code>N+1</code> 쿼리 문제? - N개의 데이터를 조회한 경우, 각 데이터들의 연관 관계를 추가적으로 조회하기 위해 한 번씩 더 조회해야하는 문제&mldr; 아주 악명 높은 문제로 자료를 쉽게 찾아볼 수 있다.</p></blockquote><p>사실 어떻게 보면 N+1 쿼리 문제가 워낙 악명이 높아 그에 대한 해결책들도 간단하게는 많이 소개되는 것 같기도 합니다. 따라서 이번 글에서는 조금은 특이하게 <strong>조회수나 댓글 개수처럼 일종의 Count 기능이 필요한 경우의 N+1 쿼리 문제나 요청마다 매번 수행되는 Join이나 연산들로 인한
오버헤드들을 줄여 최적화</strong>하는 방법은 어떤 것들이 있을지에 대한 제 고민을 소개해보려 합니다.</p><p><strong><em>(이 글은 RDB를 메인 DB로 사용하는 경우를 기준으로 작성했습니다.)</em></strong></p><h2 id=영상-조회수-같은-count-성격의-값에-대한-작업을-최적화하지-않으면>영상 조회수 같은 Count 성격의 값에 대한 작업을 최적화하지 않으면?!</h2><ul><li>쏟아지는 영상 조회 이벤트마다 RDB에 데이터를 Write => RDB에 너무 큰 부하</li><li>매번 특정 영상과 관련된 조회 내역을 RDB에서 Join 후 그 개수를 계산 => RDB에 부하, 느린 작업</li><li>RDB에 영상 조회 이벤트를 Write할 때 영상 정보 테이블에 view_count 컬럼을 추가한 뒤 view_count 컬럼에 조회수를 캐시 => 캐시 정확도 문제, 테이블 정의 변경 필요</li></ul><p>영상 조회수 같은 Count 성격의 값을 최적화해주지 않으면 위와 같은 문제들이 발생할 수 있다고 봅니다.</p><p>따라서 영상 조회 이벤트처럼 쏟아지는 데이터는 너무 많은 Write 요청은 RDB가 아닌 NoSQL을 사용하는 게 좋을 수 있을 것입니다.</p><p>하지만 NoSQL에 영상 조회 이벤트를 저장한다 해도 매번 영상 조회 내역을 가져온 뒤 그 개수를 계산하는 방식은 어떤 DB를 사용하던 불필요한 Read도 많이 발생할 것이고, 당연히 느리겠죠. 만약 어떤 영상의 조회수가 10만인 경우 10만개의 이벤트들을 조회한 뒤 그 개수를 이용해야할테니 말입니다.
경우에 따라서는 영상 조회 시 각 영상에 대한 조회 내역을 추가적으로 조회하게 되는 N+1 쿼리 문제를 겪을 수도 있습니다.</p><p>따라서 <strong><code>view_count</code> 같은 column을 추가적으로 두는 건 어떨까</strong>싶기도 합니다만 일반적으로는 <strong>동시성 이슈로 인해 view_count의 정확도가 떨어지게 될 것</strong>입니다. 또한 <strong>스키마가 강요되는 RDB의 특성에 의해 테이블 정의가 변경되어야할 수도 있습니다</strong>.</p><blockquote><p>동시성 이슈 - 만약 100명의 유저에 대한 영상 조회를 동시에 처리하는 경우 100개의 스레드는 모두 view_count=0 으로 조회를 한 뒤 자신의 조회 이벤트로 인한 +1을 더해 view_count=1로 업데이트 커맨드를 날리겠지만 사실 view_count는 1이 아닌 100이 되어야 정확한 것이다.</p></blockquote><h2 id=redis를-도입해보면-어떨까>Redis를 도입해보면 어떨까</h2><p><code>Redis</code>는 메모리를 기반으로하는 Key-Value 형태의 NoSQL라서 일반적인 RDB에 비해 아주 빠르면서 싱글 스레드 기반이기 때문에 정확한 Count와 Increment가 가능합니다. 따라서 아까 발생했던 문제들을 다음과 같이 해결할 수 있을 것입니다.</p><ul><li><p>쏟아지는 영상 조회 이벤트마다 RDB에 데이터를 Write</p><p>=> <del>RDB에 너무 큰 부하</del> (X), <strong>빠른 Write</strong> (O)</p></li><li><p>매번 특정 영상과 관련된 조회 내역을 RDB에서 Join 후 그 개수를 계산</p><p>=> <del>RDB에 부하, 느린 작업</del> (X), <strong>Redis에 최근 조회 내역을 저장</strong>, 상황에 따라 NoSQL에서 Replicate해서 영구화하는 것도 좋음 (O)</p></li><li><p>RDB에 영상 조회 이벤트를 Write할 때 영상 정보 테이블에 view_count 컬럼을 추가한 뒤 view_count 컬럼에 조회수를 캐시</p><p>=> <del>캐시 정확도 문제</del> (X), <strong>Redis의 싱글스레드 기반의 정확한 계산</strong></p><p>=> <del>테이블 정의 변경 필요</del> (X), <strong>NoSQL의 유연함</strong> (O)</p></li></ul><p>이런 이유로 인해 추후에 <strong>조회수나 댓글 수, 팔로워 수 등등에 대해 Redis를 이용하면 어떨까 싶은 생각이 드네요~!</strong> 그럼 실제로 앞서 소개했던 문제 상황이나 해결 방법들이 각각 성능이 어떨지 직접 데이터와 쿼리를 이용해 실험해보겠습니다.</p><h2 id=실제-실험을-통해-각각의-방식-성능-비교>실제 실험을 통해 각각의 방식 성능 비교</h2><h3 id=상황-소개>상황 소개</h3><ul><li>Local에서 Redis container, MySQL container을 이용. Go언어로 가볍게 애플리케이션 작성</li><li>MySQL의 Video 테이블에 1000개의 영상 데이터 존재. 조회수를 캐시해놓은 view_count 컬럼 존재.</li><li>MySQL의 View 테이블에 약 2천만 개의 조회 내역 존재.(즉 영상 당 수천개의 조회 내역 존재) 인덱스는 잘 걸어놓음.</li><li>Redis에 <code>key=video_view_count:{{video_id}}</code>, <code>value={{view_count}}</code> 형태로 view_count 캐시</li><li><strong>랜덤하게 5개의 영상에 대한 정보를 제공할 것인데 이때 조회수도 포함되어야한다.</strong></li></ul><h3 id=비교할-방식들-소개>비교할 방식들 소개</h3><ul><li><strong>Select 후 Redis에 캐시된 조회수 이용</strong><ul><li>영상에 대한 정보 자체는 Video 테이블을 이용해 Read</li><li>조회수는 Redis에 캐시된 값을 MGET을 통해 배치(벌크)로 조회해와서 이용</li></ul></li><li><strong>Select 하며 Column에 캐시된 조회수 이용</strong><ul><li>영상 정보와 조회수 모두 Video 테이블을 통해 바로 Read</li></ul></li><li><strong>Select 후 Batch로 In-Query</strong><ul><li>JPA를 이용하면서 흔히 발생했던 N+1 쿼리를 Batch로 해결할 때와 동일하게 Video 테이블 조회 후 View 테이블에서 view.id in (?,?,&mldr;) 의 형태로 In-Query를 이용</li></ul></li><li><strong>Select 후 나중에 각각을 Join</strong><ul><li>N+1 쿼리 문제 그 자체..!</li></ul></li></ul><h3 id=실험-결과>실험 결과</h3><p><figure style=flex-grow:321;flex-basis:772px><a href=/blog/optimizing-count-query-strategy/result-1.png data-size=2520x783><img src=/blog/optimizing-count-query-strategy/result-1.png srcset="/blog/optimizing-count-query-strategy/result-1_hu2b8142f32263cafd399ddd7e1ab96ace_456229_480x0_resize_box_3.png 480w, /blog/optimizing-count-query-strategy/result-1_hu2b8142f32263cafd399ddd7e1ab96ace_456229_1024x0_resize_box_3.png 1024w" width=2520 height=783 loading=lazy alt="실험 결과 1"></a><figcaption>실험 결과 1</figcaption></figure></p><ol><li>🥇 <strong>Select 하며 Column에 캐시된 조회수 이용</strong></li><li>🥈 <strong>Select 후 Redis에 캐시된 조회수 이용</strong></li><li>🥉 <strong>Select 후 나중에 각각을 Join</strong></li><li><strong>Select 후 Batch로 In-Query</strong></li></ol><p>우선은 어떤 쪽으로든 캐싱을 이용하는 게 참 빠르구나 싶었습니다. 하지만 조금 의아할 수 있는 부분들도 존재하는데요.</p><ol><li><strong>Redis에 조회수를 캐싱한 경우보다 MySQL에 캐싱한 경우가 더 빠르네..?</strong></li></ol><p>어떻게보면 당연하겠지만 <strong>MySQL에서 Join 없이 view_count를 조회할 수만 있다면 Redis를 거치는 것보다 MySQL만으로 처리하는 것이 더 빠를 것</strong>입니다.</p><p>하지만 Redis를 사용하는 이유가 Read 속도때문만은 아닐 것입니다. 앞서 말씀드린 대로 <strong>싱글 스레드 기반의 정확한 count</strong>가 가능할 것이고, RDB의 <strong>테이블 스키마를 변경할 필요도 없죠</strong>.</p><p>그리고 무엇보다 영상 조회 이벤트 발생마다 RDB의 특정 row의 조회수를 +1 하여 update 하는 것보다는 redis에서 increment하는 것이 빠를 것입니다! 즉, <strong>write까지 고려하면 속도 측면에서도 redis가 빠를 것</strong>입니다.</p><ol start=2><li><strong>N+1 쿼리 문제를 야기하는 방식이 Batch로 In-Query하는 방식보다 빠르네..?</strong></li></ol><p>이 부분은 정확한 원인은 모르겠지만 아마 추측컨대 Batch 방식으로 한 번에 몇 만개 수준의 너무나 많은 데이터를 카티션 곱으로 조회한 뒤 각 video의 조회수 내역으로 넣어주려다보니 조회 후 연산이 많은 시간을 잡아먹은 게 아닐까 싶습니다.
반면 N+1 쿼리 방식은 각 video에 대해 한 번씩 쿼리한 뒤 바로 그 결과 count 할 수 있으니 이런 특수한 경우(데이터가 엄~청 많은 경우)에는 오히려 Batch 방식이 느릴 수 있는 게 아닐까 싶습니다.</p><p>실제로 조회수가 약 10개 정도인 영상을 똑같이 5개 조회해보니 우리의 일반적인 예상대로 Batch 방식이 N+1 쿼리보다 빨랐는데요! 아마 카티션 곱이 일어났지만 양 자체가 적은 쿼리 결과를 처리하는 것이 redis와의 N번의 통신이 더 느리기 때문이 아닐까 싶습니다.</p><h2 id=조회수를-위해-가장-이상적인-아키텍쳐는>조회수를 위해 가장 이상적인 아키텍쳐는?!</h2><p><figure style=flex-grow:106;flex-basis:255px><a href=/blog/optimizing-count-query-strategy/architecture.png data-size=1315x1236><img src=/blog/optimizing-count-query-strategy/architecture.png srcset="/blog/optimizing-count-query-strategy/architecture_hu2e0266c55b356006b8efd84bbe6e386e_394889_480x0_resize_box_3.png 480w, /blog/optimizing-count-query-strategy/architecture_hu2e0266c55b356006b8efd84bbe6e386e_394889_1024x0_resize_box_3.png 1024w" width=1315 height=1236 loading=lazy alt="상상 속 아키텍쳐"></a><figcaption>상상 속 아키텍쳐</figcaption></figure></p><p>실험 결과에서도 Redis를 사용하는 것이 나쁘지 않은 것으로 보여집니다. 그래서 저라면 정말 이런 식으로 <strong>최적화를 해볼 수 있는 기회가 있다면 Redis를 도입</strong>해볼 것 같습니다. 그 동안 수없이 고통받아왔던 N+1 쿼리 문제도 어느 정도 해결할 수 있겠죠?!
<strong>불필요한 양방향 연관 관계는 최대한 단방향 연관 관계로 제한하고, Count가 필요할 때 각 엔티티마다의 특정 Count 값을 위해 N번의 쿼리를 수행할 필요도 없어질 것</strong>입니다.</p><p>하지만 Redis를 도입한다고 만사가 해결되는 것은 아닐 것입니다. Redis는 영속성이 보장되지 않으므로 영상 조회 내역이 증발해버릴 수도 있고, 양이 한정적일 수 있죠. 그래서 저는 단순 Redis 뿐만 아니라 다음과 같은 방식은 어떨까 생각해보고 있습니다.</p><ul><li><strong>최근 영상 조회 내역</strong>은 <code>view_histories:{{username}}</code> 형태의 key, <code>{{video_id}}</code> 형태의 value로 1차적으로 Redis에 저장한다. <strong>조회수</strong>는 <code>view_count:{{vide_id}}</code> 형태의 key, <code>{{view_count}}</code> 형태의 value로 Redis에 캐시한다.<ul><li>최근 영상 조회 내역을 redis를 통해 빠르게 읽고 쓸 수 있다.</li><li>영상 조회수를 Redis의 Increment로 비교적 정확하게 계산할 수 있다.</li><li>유저의 최근 영상 조회 내역을 각 유저별로 TTL을 걸 수 있다. => Redis 메모리 절약</li><li>영상의 조회수를 영상별로 TTL 걸 수 있다 => Redis 메모리 절약</li></ul></li><li>영상 조회 이벤트 저장 시 Redis의 <code>event:video_viewed</code> 라는 key의 List에 앞서 언급한 조회 내역과 동일한 조회 내역을 저장한다.(메시지 큐에 Enqueue하는 느낌)<ul><li>SQS 같은 Message queue는 조회수 이벤트가 쏟아지는 것에 비해 latency가 느림. 따라서 Redis를 큐로 사용하는 것도 괜찮아보임.</li></ul></li><li>Redis <code>event:video_viewed</code> 라는 List에서 조회 이벤트를 뽑아 서버리스한 NoSQL인 DynamoDB에 유저의 조회 내역을 영구적으로 저장한다.<ul><li>영상 조회 내역을 redis에 캐시할 뿐만 아니라 영구적으로 저장하기 위함.</li><li>마치 Redis를 버퍼, Write-back cache로 이용하는 느낌인데 NoSQL이라해도 주기적인 Bulk write은 주기때마다 부담될 수 있음. 그리고 조회 이벤트는 계속 계속 빠르게 확장될 수 있기 때문에 NoSQL 중에도 서버리스인 DynamoDB를 사용하면 어떨까 싶음. (주의: DynamoDB 안써봄&mldr;)</li></ul></li></ul><p>(단 위의 아키텍쳐는 제 개인적인 생각일 뿐, 실제로는 어떻게들 사용하시는지 궁금하네요..! 이렇게 직접 한 필드에 대해 복잡한 방식을 이용하기보단 좀 더 단순히 캐싱 프레임워크를 이용하는 것도 좋은 선택지일 수도 있을 것 같구요.)</p><h2 id=마치며>마치며</h2><p>이렇게 Count 성향의 작업을 어떻게 최적화할 수 있을지 상상과 실험을 통해 정리해봤습니다. 중요한 것은 하나의 정답이 존재하는 것이 아니고, 처한 상황마다 천차만별의 솔루션들이 있을테니 각각을 잘 비교해보고 잘 PoC 한 뒤 사용하는 것인 듯합니다.</p><p>캐시나 Redis에 대해 관심이 많은 편이지만, 아직 많이 부족하다보니 좋은 말씀 댓글로 달아주시면 감사히 배워나가겠습니다~! 감사합니다.</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>관련 글</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/blog/khumu/khumu-dev-review/><div class=article-image><img src=/blog/khumu/khumu-dev-review/thumbnail-wide.16a51be9bcaaaf44d2817ddfb9587707_hu54b7b06ccaab22efd2d5450276cad720_83729_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-FqUb6byqr0TSgX3fuVh3Bw=="></div><div class=article-details><h2 class=article-title>쿠뮤 MVP 개발기</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//umi0410.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 Jinsu Playground</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.4.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#시작하며>시작하며</a></li><li><a href=#영상-조회수-같은-count-성격의-값에-대한-작업을-최적화하지-않으면>영상 조회수 같은 Count 성격의 값에 대한 작업을 최적화하지 않으면?!</a></li><li><a href=#redis를-도입해보면-어떨까>Redis를 도입해보면 어떨까</a></li><li><a href=#실제-실험을-통해-각각의-방식-성능-비교>실제 실험을 통해 각각의 방식 성능 비교</a><ol><li><a href=#상황-소개>상황 소개</a></li><li><a href=#비교할-방식들-소개>비교할 방식들 소개</a></li><li><a href=#실험-결과>실험 결과</a></li></ol></li><li><a href=#조회수를-위해-가장-이상적인-아키텍쳐는>조회수를 위해 가장 이상적인 아키텍쳐는?!</a></li><li><a href=#마치며>마치며</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>