<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>메가존 클라우드 데브옵스 인턴 후기 on Jinsu Playground</title><link>https://umi0410.github.io/blog/megazone-cloud/</link><description>Recent content in 메가존 클라우드 데브옵스 인턴 후기 on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 04 Sep 2020 12:46:54 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/blog/megazone-cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>메가존 클라우드 데브옵스 인턴 후기</title><link>https://umi0410.github.io/blog/megazone-cloud/index/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/index/</guid><description>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/index/mzcloud-logo.png" alt="Featured image of post 메가존 클라우드 데브옵스 인턴 후기" />&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/index/mzcloud-logo.png"
width="194"
height="50"
srcset="https://umi0410.github.io/blog/megazone-cloud/index/mzcloud-logo_huaed2850ad2750bd21c0ea378f4b3d958_6575_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/index/mzcloud-logo_huaed2850ad2750bd21c0ea378f4b3d958_6575_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="mzc_logo"
class="gallery-image"
data-flex-grow="388"
data-flex-basis="931px"
>&lt;/p>
&lt;p>안녕하세요. 이번에 &lt;strong>메가존 클라우드&lt;/strong>의 클라우드 원 팀에서 &lt;strong>데브옵스 인턴&lt;/strong>으로 근무를 하게되었던 &lt;strong>박진수&lt;/strong>입니다.
너무 좋은 팀원들과 많은 경험을 하며 단시간에 성장할 수 있었고, 일하는 동안 매 순간 순간이 너무
행복했었기에 이렇게 인턴 후기를 작성해봅니다. 한 학기를 쉬고 2020.04.13~2020.08.31 까지 인턴으로 근무 했고,
다시 2020-2학기부터는 학교 복학을 하게되었습니다.
기술적인 얘기는 이곳 저곳에 많으니 항상 제가 가장 중요시하는
&lt;strong>&amp;ldquo;느낀 점&amp;rdquo;&lt;/strong> 과 &lt;strong>&amp;ldquo;배운 점&amp;rdquo;&lt;/strong> 을 위주로 적어보겠습니다!!
글은 위의 목록의 순서로 진행해보겠습니다.&lt;/p>
&lt;h2 id="지원동기">지원동기&lt;/h2>
&lt;p>저는 AWS와 배포에 관해 흥미가 있어 종종 &lt;a class="link" href="https://awskrug.github.io/" target="_blank" rel="noopener"
>AWSKRUG&lt;/a> 라는 그룹의 소모임에 가서 핸즈온이나 세미나에
참여하곤 했는데요. 그곳에서 저희 팀원들을 만나게 되었고, 그것이 인연이 되어
채용으로까지 이어질 수 있었습니다.&lt;/p>
&lt;p>평소 &lt;a class="link" href="https://velog.io/@ausg" target="_blank" rel="noopener"
>AUSG&lt;/a> 라는 대학생 AWS 사용자 모임의
일원으로서 참여하며 &lt;code>AWS&lt;/code> 를 이용한 클라우드 인프라, &lt;code>CI/CD&lt;/code> 파이프라인 구축을 통한 자동화, &lt;code>컨테이너&lt;/code> 등에
관심이 많았는데, 마침 메가존 클라우드의 저희 CloudOne 팀에서는 팀의 모든 마이크로서비스 및 기타 서비스들을
&lt;code>EKS&lt;/code>라는 &lt;code>AWS&lt;/code>의 Managed Kubernetes Cluster Service 위에 자동화시켜 배포를 하고있었고,
개발 인프라를 이전하려던 참이었기에 저의 관심사와 향후 목적에 잘 부합했습니다.&lt;/p>
&lt;h2 id="megazone-cloud-cloudone-team">Megazone Cloud: CloudOne Team?&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a class="link" href="https://www.megazone.com/" target="_blank" rel="noopener"
>Megazone Cloud&lt;/a>: 국내 최초 &amp;amp; 최대 AWS 프리미어 컨설팅 파트너, AWS 컨설팅, 구축, 운영 및 빌링 서비스 제공. 메가존클라우드는 2009년부터 클라우드를 차세대 핵심 사업으로 성장시키며 ‘클라우드 이노베이터(Cloud Innovator)’로서 고객님들의 클라우드 전환의 과정마다 최선의 선택을 하실 수 있도록 다양한 서비스를 제공하고 있습니다. - 출처(&lt;a class="link" href="https://www.megazone.com/" target="_blank" rel="noopener"
>https://www.megazone.com/&lt;/a>)&lt;/p>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/index/spaceone_preview_2.png"
width="1309"
height="837"
srcset="https://umi0410.github.io/blog/megazone-cloud/index/spaceone_preview_2_huee8c22ea49c5670715faa4f26b6ccdf9_132613_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/index/spaceone_preview_2_huee8c22ea49c5670715faa4f26b6ccdf9_132613_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="spaceone_preview_2"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;code>AWS&lt;/code> &lt;code>EKS&lt;/code>를 이용한 &lt;code>Kubernetes&lt;/code> 환경, 마이크로서비스 아키텍쳐&lt;/li>
&lt;li>Composition API를 이용하는 최신 &lt;code>Vue&lt;/code> 기술&lt;/li>
&lt;li>&lt;code>Terraform&lt;/code>을 통한 &lt;code>IaC&lt;/code>&lt;/li>
&lt;li>자동화된 &lt;code>CI/CD&lt;/code>, 다양한 배포 전략, 인프라 &lt;code>모니터링&lt;/code>&lt;/li>
&lt;li>HTTP2를 이용한 &lt;code>gRPC&lt;/code> API&lt;/li>
&lt;/ul>
&lt;h2 id="진행했던-업무들">진행했던 업무들&lt;/h2>
&lt;blockquote>
&lt;p>링크 형식이므로 링크를 눌러 읽어주시면 됩니다.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a class="link" href="../stargate-infra" >2020.04: Stargate 라는 개발 인프라를 구축&lt;/a>
&lt;ul>
&lt;li>terraform 을 통한 개발 인프라 구축&lt;/li>
&lt;li>EKS 클러스터에 jenkins, spinnaker, grafana 등등의 개발 도구들을 배포함&lt;/li>
&lt;li>종종 발생하는 장애 상황을 멘토님과 트러블슈팅함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="../ci-cd-pipeline" >2020.05: 개발 CI/CD 파이프라인 구축&lt;/a>
&lt;ul>
&lt;li>Experiment 환경에 배포 =&amp;gt; Test, CI =&amp;gt; Development 환경에 배포를 자동화&lt;/li>
&lt;li>Spinnaker와 Jenkins, Github Action을 이용한 자동화 파이프라인 구축&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="../argo-poc" >2020.06: Argo Project들을 PoC&lt;/a>
&lt;ul>
&lt;li>argo cd, argo(workflow), argo-event 등의 다양한 프로젝트에 대한 PoC를 진행&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="../spaceone-helm" >2020.07: spaceone-helm Helm3 Chart 개발&lt;/a>
&lt;ul>
&lt;li>개별로 배포되고 운영되던 우리 팀의 서비스인 SpaceONE을 패키지로 배포할 수 있게해주는 Helm Chart를 개발&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="../spacectl" >2020.08: spacectl 설계, 개발 참여&lt;/a>
&lt;ul>
&lt;li>우리 팀의 서비스인 SpaceONE에 대한 API 작업을 수행하는 CLI 도구에 대한 설계와 개발에 참여함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="느낀-점">느낀 점&lt;/h2>
&lt;p>그 동안 혼자 개발 및 평소 관심분야였던 클라우드, 컨테이너 등등의 주제로 공부해왔었는데,
과연 이 내용들이 정말 실무에 도움이 될 지, 제가 잘 나아가고 있는 건지 확신이 들지 않았습니다.
하지만 &lt;code>CloudOne&lt;/code>팀에서 다양한 경험을 하면서 &amp;lsquo;제가 공부해온 길이 틀리지만은 않았구나&amp;rsquo;라는 느낌을 받을
수 있었고, 보완해야할 부분들은 보완하면서 불확실한 자세가 아닌 확신과 열정을 가진 자세로
좀 더 몰두할 수 있을 것 같습니다!&lt;/p>
&lt;p>배우고 느낀 내용이 너무 많아 글이 다소 길어졌습니다. 기술을 거부감 없이 접하되
기술이 다가 아닌, 팀원들을 위해 솔선수범하는 개발자,
팀원들의 생각을 읽어줄 수 있고, 잘 이해해줄 수 있는 개발자가 되기 위해 노력해야겠단 생각이 듭니다.
쉽진 않겠지만, 나아가고 싶은 방향은 정해진 것 같아 다행입니다!&lt;/p></description></item><item><title>1. Stargate라는 인프라 구축기</title><link>https://umi0410.github.io/blog/megazone-cloud/stargate-infra/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/stargate-infra/</guid><description>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/stargate-infra/dev-architecture.svg" alt="Featured image of post 1. Stargate라는 인프라 구축기" />&lt;h2 id="stargate라는-개발-인프라-구축기">Stargate라는 개발 인프라 구축기&lt;/h2>
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/stargate-infra/dev-architecture.svg"
loading="lazy"
alt="dev-architecture.svg"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>저희 팀의 개발 인프라는 위와 같습니다. 마침 제가 입사할 쯤이 기존에 존재하던 인프라를 새로운 환경으로
이전해야할 시점이었습니다. 덕분에 저는 저희 개발 환경을 처음부터 구축하고, 우리의 서비스를
배포해보고, 그 후 운영하면서 여러 경험들을 할 수 있었습니다.&lt;/p>
&lt;h3 id="terraform으로-처음-접해-본-iac">Terraform으로 처음 접해 본 IaC&lt;/h3>
&lt;blockquote>
&lt;p>친구: IaC가 뭔 지 알아? 써봤어?&lt;/p>
&lt;p>본인: 뭐 인프라를 코드로 관리한다는 건데, 나도 몰라 ㅋㅋ&lt;/p>
&lt;p>본인: 아마 너무 고급 기술이라 대학 졸업할 때 까진 못 써볼 듯?&lt;/p>
&lt;/blockquote>
&lt;p>위의 대화는 제가 입사하기 약 일주일 전에 나눴던 대화인데, 입사 후에는 어느 덧 &lt;code>IaC&lt;/code>와 꽤나 친근해진 것 같아
유머삼아 유머로 가져와봤습니다. &lt;code>메가존 클라우드&lt;/code>의 &lt;code>클라우드 원&lt;/code>팀에서
일하기 전까지는 &lt;code>IaC&lt;/code>는 저와는 거리가 먼 토픽이었고, &lt;code>Kubernetes&lt;/code> 또한 &lt;code>minikube&lt;/code>로
몇 가지 Object들을 배포해본 것이 다였습니다. 하지만, 저는 저희 팀에서 근무하게 되면서
&lt;code>terraform&lt;/code>을 통해 위의 차트에 그려진 모든 인프라를 구축하고 파이프라인을 구축하게 됩니다.&lt;/p>
&lt;p>&lt;code>terraform&lt;/code>을 사용하며 느꼈던 점은 &amp;lsquo;장점만 존재하는 기술은 드물 것이다&amp;rsquo;라는 점입니다.
분명 대부분은 장점이 있으면 그에 따른 단점이 존재할 것이고, 개인적으로는 테라폼도 장단점이 공존하고있다는
느낌을 받았습니다.
저의 주관적인 느낌에 따른 가장 큰 장점과 단점을 몇 개만 설명해보겠습니다.&lt;/p>
&lt;h3 id="terraform-단점">Terraform 단점&lt;/h3>
&lt;p>우선 단점부터. &lt;em>&amp;ldquo;사소한 인프라 변경도 코드에 반영하려면 문서를 찾아봐야하고, plan 내용을
검토해야한다&amp;rdquo;&lt;/em>.&lt;/p>
&lt;p>저희는 평소에는 &lt;code>EKS의 로그&lt;/code>를 켜놓지 않았습니다. 그런데 언젠가 EKS 로그를 &lt;code>CloudWatch&lt;/code>를
이용해 분석해야한 적이 있는데, AWS 콘솔에서 바로 눈 앞에 로그 설정 칸이 있었음에도
EKS 로그를 설정하는 terraform Docs를 찾아본 뒤 plan을 분석한 뒤 apply 했어야합니다. 물론
아마도 로그 설정 쯤이야 잠깐 콘솔로 설정했다가 콘솔로 해제하면 그 한 번쯤은 문제가 없었겠지만,
그런 식으로 이번 한 번만, 이것쯤이야 하면서 코드가 아닌 매뉴얼로 직접 인프라 형상을
제어하는 경험이 쌓이게되면 형상이 깨져서 다시 형상을 맞추기 힘들수도 있고, 애초에
그런 수작업이 많이 들어가야하는 경우가 있다면 오히려 IaC를 이용할 필요가 없다고
생각했기 때문에 최대한 인프라는 terraform code로만 작업한다는 저의 원칙을 지키기
위함이었습니다.&lt;/p>
&lt;p>즉 자동화보다는 수작업이 편한 경우는 굳이 IaC라는 컨셉을 이용하는 것이
더 불편한 경우도 존재할 수 있을 것 같다는 생각이 들었습니다.&lt;/p>
&lt;h3 id="terraform-장점">Terraform 장점&lt;/h3>
&lt;p>&lt;em>&amp;ldquo;내가 사용하고 있는 인프라 전체를 한 눈에 보기 쉽다&amp;rdquo;&lt;/em>&lt;/p>
&lt;p>물론 클라우드 서비스 하나에 대한 정보를 보고싶으면, 웹 콘솔에 들어가서 확인하는 것이 편하겠지만,
내가 이용하고 있는 AWS내의 모든 클라우드 서비스에 대한 정보나 설정을 보기에는 terraform 코드나
output, state 등이 더 알아보기 편할 수 있습니다.&lt;/p>
&lt;p>&lt;em>&amp;ldquo;혹시 장애가 생긴 경우 그 원인을 추적하기 쉽다.&amp;rdquo;&lt;/em>&lt;/p>
&lt;p>수작업으로 클라우드 인프라를 관리하는 경우에 자신이 모르는 어떤 변동사항이 있고, 그 변동사항이
어떤 버그를 야기하고 있다면, 수작업으로 작업을 진행하는 경우에는 그 변동사항을 알아채고 트러블슈팅하기
쉽지 않을 것입니다.&lt;/p>
&lt;p>하지만 테라폼 코드를 통해 인프라를 관리하면 변동사항을 테라폼이 알아서 잡아주고, 혹은 코드에 대한
커밋 내역 등을 통해 변동 사항을 체크해 볼 수도 있을 것입니다. 따라서 그 변동사항에 맞는 트러블 슈팅을
하기 쉬울 것 입니다.&lt;/p>
&lt;h3 id="개발-관련-다양한-서비스-배포">개발 관련 다양한 서비스 배포&lt;/h3>
&lt;p>테라폼으로 인프라를 구축한 뒤에는 위의 차트에서 오른쪽에 작게 &lt;code>Stargate&lt;/code> 라는 곳에 적힌
서비스들을 배포했습니다. 이 부분에 대해서는 너무나도 하고싶은 얘기가 많지만, 지루해질 수 있으니
그 중 기억에 많이 남거나 애착이 가는 서비스들에 대한 리뷰를 간단히 적어보겠습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Nginx Ingress Controller&lt;/strong>
&lt;ul>
&lt;li>로컬에서 minikube로만 개발하다가 처음으로 &lt;code>Ingress&lt;/code>를 사용하게 되었습니다.
helm을 이용한 게 아니라, helm으로 만들어진 manifest를 수동으로 하나하나 설정해서
설치하고 관리했습니다. 설정이 꽤나 복잡했었기에 설정을 많이 변경하는 경우
helm으로 설치하는 건 어떨까싶습니다&amp;hellip; 일하면서 Nginx로 L7 로드밸런싱 뿐만 아니라
L4 로드밸런싱도 몇 번 다룰 일이 있었고, 여러 Nginx Ingress Controller을 배포할
일도 있었고, &lt;code>gRPC&lt;/code> 통신을 위한 설정을 해야할 일도 있었는데, 점점 수작업으로 하다보니
설정이 너무 복잡해져서 헷갈렸던 적이 있습니다. 뭔가 단점만 적은 것 같은데, K8s의
Ingress Controller로서 성능적인 부분은 제가 잘 모르겠지만, 크게 불편함 없이
잘 사용했습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>ALB Ingress Controller&lt;/strong>
&lt;ul>
&lt;li>서비스에 대해 직접 L7 로드밸런싱을 수행할 경우 이용합니다.&lt;/li>
&lt;li>헷갈렸던 점은 보통은 Nginx Ingress Controller는 사실 Ingress는 설정이고,
컨트롤러가 실제로 로드밸런싱을 수행하는데, ALB는 ALB Ingress Controller가 Ingress를
통해 ALB를 만들고 실제 로드밸런싱은 ALB Ingress Controller가 아니라 ALB가 한다는 점이었습니다.&lt;/li>
&lt;li>설정에 따라 다르지만 기본적으로는 노출시키고자 하는 서비스는 &lt;code>NodePort&lt;/code>급 이상으로 서비스가 열려있어야하는데,
실수로 ClusterIP로 노출시켜 ALB가 서비스를 제대로 찾지 못한 적이 종종 있었습니다. 주의..!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Cert Manager&lt;/strong>
&lt;ul>
&lt;li>자동으로 cert를 발급해주고 갱신해주는 서비스입니다.&lt;/li>
&lt;li>Let&amp;rsquo;s Encrypt를 이용했고 무료입니다.&lt;/li>
&lt;li>정말 정말 편리했습니다!&lt;/li>
&lt;li>&lt;code>DNS&lt;/code>, &lt;code>HTTP Challenge&lt;/code>, &lt;code>TLS&lt;/code>에 대해 많이 배울 수 있었습니다.&lt;/li>
&lt;li>TLS 통신 과정은 공부해도해도 정확한 순서는 까먹게 돼서&amp;hellip; 다시 공부해봐야겠습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Jenkins&lt;/strong>
&lt;ul>
&lt;li>편한데, 관리하기 귀찮을 수 있을 것 같습니다.&lt;/li>
&lt;li>결정적으로 코드로 관리할 수도 없는데, UI도 그렇게 직관적인지는 잘 모르겠습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Spinnaker&lt;/strong>
&lt;ul>
&lt;li>정말 편리합니다. Jenkins test 결과를 CD에 이용할 수도 있고, 편리하고 다양한 문법, 파이프라인 종류,
직관적인 UI/UX. 사실 Argo를 도입하고 싶었지만, &lt;code>Argo&lt;/code>는 약간 가벼운 쿠버 환경에 대한 배포용 같은 느낌,
&lt;code>IaC&lt;/code>는 적극 도입되었으나 현실에 도입은 쉽지 않은 기술적 이상향 같은 느낌이 컸고,
현실적으로는 좀 더 안정적인 &lt;code>Spinnaker&lt;/code>를 유지하게 됐습니다.&lt;/li>
&lt;li>좀 느리다고 생각했는데, 이 글을 쓰면서 생각해보니 개발에서는 K8s Deployment의 &lt;code>Grace Period&lt;/code> 때문인 것 같아
그걸 좀 줄여볼 껄 싶습니다. 즉 다시 생각해보니 별로 느리지 않은 듯합니다.&lt;/li>
&lt;li>배포 자체는 안정적이고 좋은데, 설정할 때 버그가 종종 있습니다. 버그인지 제 실수인지는 모르겠지만
Pipeline stage 에서 Bake라는 모드가 &amp;ldquo;우와 신박하다!&amp;rdquo; 라고 생각했지만, 설정이 제대로 되지 않거나,
OAuth login 실패에 대한 처리, Artifact 경로 설정이 너무 번거로운 점 등의 단점이 있었습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Keycloak&lt;/strong>
&lt;ul>
&lt;li>우리의 개발툴들에 대한 인증을 사내 계정으로 연동시켜주는 &lt;code>Single Sign On&lt;/code> 기능을 지원했습니다.&lt;/li>
&lt;li>새로운 팀원은 각 서비스에 별도의 가입 과정 없이, 앱 레벨에서 따로 권한 부여가 필요한
것이 아니라면 사내 계정으로 바로 이용이 가능했습니다.&lt;/li>
&lt;li>문서가 제대로 정리된 게 다소 부족한 느낌이었어서 세밀한 설정이나 정확한 작동원리를 파악하기는 쉽지 않았던
점이 조금 아쉽습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="인프라-구축에-대한-정리">인프라 구축에 대한 정리&lt;/h2>
&lt;p>내용이 너무 길어지면 읽기 힘들 것 같아 최대한 느낀 점 위주로 간단히 정리해보려고 노력해보았습니다.
인턴으로 일을 하기 전에 가벼운 마음 속 목표가 하나 있었습니다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>&amp;lsquo;어떤 걸 어느정도 사용해보면 그것에 대한 주관적인 평가를 내릴 수 있는 사람이 되고싶다.&amp;rsquo;&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>누군가 &amp;ldquo;&lt;code>도커&lt;/code>가 설치하기 정말 쉽더라구요.&amp;rdquo;, &amp;ldquo;&lt;code>minikube&lt;/code> 써보니 정말 편리하더라구요.&amp;rdquo;, &amp;ldquo;&lt;code>Jenkins&lt;/code> 보다는 &lt;code>travis&lt;/code>가 편리더라구요.(혹은 그 반대)&amp;rdquo;
이런 얘기가 나와도 과거에는 공감할 수도, 제 주관적인 평가를 내릴 수도 없었습니다. 저의 경험으로 구성된
모집단이 없었기 때문입니다. 하지만 저희 클라우드 원 팀에서 근무하면서 어떻게 보면 깊이는 다소 얕았을 지 몰라도
정말 다양한 서비스를 접하고 다채로운 경험을 할 수 있었던 것 같습니다! 덕분에 이제는 어떤 서비스를 접하든,
새로운 언어를 접하는 저만의 느낌을 가질 수 있고, 의견을 말할 수 있을 것 같습니다!&lt;/p></description></item><item><title>2. Github Action, Spinnaker을 이용한 CI/CD 파이프라인 구축기</title><link>https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/</guid><description>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/ci-cd-pipeline.png" alt="Featured image of post 2. Github Action, Spinnaker을 이용한 CI/CD 파이프라인 구축기" />&lt;h2 id="github-action을-사용하게-된-배경">Github Action을 사용하게 된 배경&lt;/h2>
&lt;p>저희 팀은 원래 CI용으로 &lt;code>Jenkins&lt;/code>를 사용했습니다만 팀이 개발 중이던 서비스가
오픈소스가 목표인 프로젝트였고, Github Action이 빠르게 발전해나가면서
비용도 무료가 되었고, 좋은 Action들이 많이 생겨나고 있었기에
어느 정도 프로젝트 구조가 잡힌 뒤에는 Github의 Public Repository로 프로젝트를 관리하고
Github Action을 CI 도구로 채택하게되었습니다. Integration Test를
제외한 모든 빌드 및 일부 배포를 Github Action을 이용하게되었고, 대부분의 배포에는 사용하던대로
Spinnaker을 이용했습니다.&lt;/p>
&lt;h2 id="github-action-vs-jenkins">Github Action vs Jenkins&lt;/h2>
&lt;p>이 부분 역시 느낀 점 위주로 요약해보겠습니다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Github Action&lt;/th>
&lt;th>Jenkins&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>내가 서버를 관리할 필요가 없다.&lt;/td>
&lt;td>내가 직접 master을 띄우고, slave를 띄워우고, 관리해줘야한다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VM이 배치되어 제공되는 데에 좀 시간이 든다. 내 커스텀 이미지를 사용할 수가 없다보니 반복되는 패키지 설치나 환경 설정을 매번 해야해서 좀 느리다.&lt;/td>
&lt;td>내가 필요한 Plugin을 설치해놓거나 설정을 입력해 놓으면 매번 빌드할 때 따로 제공할 필요 없다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Code로 관리가 가능하다! 처음엔 조금 어려울 수 있지만, 알고 나면 쓰기 너무 쉽다.&lt;/td>
&lt;td>처음 접한 사람이 사용하기에는 Github Action보다 편리할 수 있지만, 그렇다고 훌륭한 UI/UX는 아닌 듯 하다.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>요즘 핫하고, 빠르게 발전 중이다.&lt;/td>
&lt;td>구식이다.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>비용이 저렴하게 풀리고 있고(퍼블릭의 경우 아마 무조건 무제한 공짜),
원래 지원하지 않던 매뉴얼 트리거가 2020.07부터 제공되기 시작했다는 점,
누구든 오픈소스로 Github Action에서 남들이 사용할 수 있는 action 을 만들 수 있다는 점등을
보고 Github Action이 빠르게 발전 중이라는 생각이 들었습니다.&lt;/p>
&lt;h2 id="그래서-어떤-cicd를-자동화하였나요">그래서 어떤 CI/CD를 자동화하였나요?&lt;/h2>
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/ci-cd-pipeline.png"
width="913"
height="1628"
srcset="https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/ci-cd-pipeline_hu2d78a6f76281dd93e8329c8b5a44cef9_282268_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/ci-cd-pipeline/ci-cd-pipeline_hu2d78a6f76281dd93e8329c8b5a44cef9_282268_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ci-cd-pipeline.png"
class="gallery-image"
data-flex-grow="56"
data-flex-basis="134px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>세로로 길어서 좀 보기 불편하실 수도 있는데, 위의 차트가 저희의 깃헙액션에 대한 차트입니다.
레포지토리마다 조금씩 다른 부분이 있고, 프론트엔드의 경우 파이프라인이 다양했는데, 우선 백엔드의
깃헙액션 및 CI/CD 진행 방식에 대해 요약해보겠습니다. (Chart를 작성한 지가 좀 돼서 설명과 조금
다른 부분이 있을 수도 있습니다.)&lt;/p>
&lt;p>개발 스프린트 진행 시에는 아래와 같이 진행되었습니다. (&amp;lt;상황 설명&amp;gt; =&amp;gt; &amp;lt;Github Action 수행 내용&amp;gt; 형식으로 나했습니다.)&lt;/p>
&lt;ol>
&lt;li>개별 Fork 후 Master Branch에 Pull Request =&amp;gt; lint, basic unit test 진행. 통과된 PR만 Merge열&lt;/li>
&lt;li>Master에 Merge 혹은 Commit이 Push됨 =&amp;gt; CI Action이 실행됩니다.&lt;/li>
&lt;li>개발용 docker registry 에 업로드&lt;/li>
&lt;li>해당 registry에 업로드 된 것을 감지하고 &lt;code>Spinnaker&lt;/code>가 Experiment 환경에 배포&lt;/li>
&lt;li>Experimental 환경을 이용해 &lt;code>Jenkins&lt;/code>가 Integration Test를 진행&lt;/li>
&lt;li>Integration Test 성공 시에 Dev 환경에 배포.&lt;/li>
&lt;/ol>
&lt;p>이후 스프린트 막바지 QA 기간에는 Experiment, Dev 환경이 주로 QA 환경으로 사용되었고,
파이프라인은 다음과 같았습니다.&lt;/p>
&lt;ol>
&lt;li>검증이 어느 정도 끝난 커밋에 대해 Git Tag를 &lt;code>{{VERSION}}-rc{{RC_NUMBER}}&lt;/code> 형태로 달아 푸시 - Github Release가 생김
=&amp;gt; 도커 이미지 빌드 후 Production Docker Registry에 이미지 업로드
=&amp;gt; tag가 달린 커밋을 기점으로 자동으로 버전 명의 브랜치를 만듦.&lt;/li>
&lt;li>Production Docker Registry의 업로드를 감지하고 Dev에서 손수 QA 진행&lt;/li>
&lt;li>문제가 있을 경우 rc number를 올려서 다시 태그를 달고 업로드 후 재차 QA&lt;/li>
&lt;li>문제가 없을 경우 해당 태그를 바탕으로 rc를 지우고 실제 버전으로서 태그를 달아 푸시 =&amp;gt; 다시 업로드&lt;/li>
&lt;li>Production은 매뉴얼 배포.&lt;/li>
&lt;/ol>
&lt;h2 id="github-action을-다뤄보면서-느낀-점">Github Action을 다뤄보면서 느낀 점&lt;/h2>
&lt;p>처음에는 Github Action에 그렇게 만족을 하지 못했습니다. 초기에는 Manual Trigger가 지원되지
않았던 데다가, 가뜩이나 Github Action을 잘 몰랐기에 한 번 Github Action을 수정하여
테스트 하고싶을 때 마다 커밋을 하나씩 날려야했던 게 불편했고, 브랜치를 따로 만들거나 fork를 떠서 Github Action 테스트 후
해당 &lt;code>workflow&lt;/code>만 마스터에 머지하는 방식 등등 다양한 방식을 사용했었는데, 어느 정도 익숙해지고 Github Action에
Manual Trigger도 등장하게 되면서 꽤나 만족도가 높아졌습니다.&lt;/p>
&lt;p>&lt;code>Jenkins&lt;/code>와 달리 제가 서버를 이용하지 않아도 된다는 점도 맘에 들긴했는데, 종종 Github 서버가 죽는 일이
발생해서 난감했던 적이 있긴합니다.&lt;/p>
&lt;p>하나 재미있었던 점은 Github Action을 이용하면서 저희의 &lt;code>CI/CD&lt;/code> 전략이 꽤나 고도화되었는데,
그 과정에서 팀원들과 자유롭게 의사소통하는 과정이 재미있었고, 저 또한 자유롭게 의견을 나눌 수 있었던 경험을 할 수 있었다는 것입니다.&lt;/p>
&lt;p>후에 저희 &lt;code>SpaceONE&lt;/code>의 CLI API 클라이언트인 &lt;code>spacectl&lt;/code>의 설계에도 &lt;code>Github Action&lt;/code>의 구조를 모티브삼았는데
이때에도 Github Action에 대한 지식이 많은 도움이 되었고, 퇴사 후에도
개인적인 Github 활동을 하면서 자유롭게 Github Action을 사용할 수 있었기에
든든한 개발 도구를 얻은 느낌입니다. 코드로 제가 하고싶은 것을 뭐든 정의할 수 있고,
만들어져 있는 작업은 편하게 가져다 쓰면 되기 때문에
빌드나 배포에 관해 재미있는 번뜩이는 아이디어가 있을 때 바로 바로 적용할 수 있고, 실제로 현재의 &lt;code>Github Page&lt;/code>도
&lt;code>Github Action&lt;/code>을 통해 다양한 트릭을 이용할 수도 있었고,
빌드 후 배포 또한 자동화 되어있습니다!&lt;/p></description></item><item><title>3. Argo Project들에 대한 PoC(개념 증명) 진행</title><link>https://umi0410.github.io/blog/megazone-cloud/argo-poc/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/argo-poc/</guid><description>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo-events-top-level.png" alt="Featured image of post 3. Argo Project들에 대한 PoC(개념 증명) 진행" />&lt;h2 id="argo-poc를-진행하게-된-배경">Argo PoC를 진행하게 된 배경&lt;/h2>
&lt;p>입사 초기부터 &lt;code>Argo&lt;/code>에 대해 간간히 이야기를 들어왔습니다. 저희는 원래 &lt;code>Spinnaker&lt;/code>을 사용했는데,
쿠버네티스 환경에 좀 더 친화적이라는 &lt;code>Argo&lt;/code>를 도입해보는 것은 어떨까에 대한 얘기였는데요.
어느정도 개발 인프라 구축이 완료되고 한가해지자 잠깐이나마 &lt;code>Argo&lt;/code>를 사용해볼 수 있었습니다.
결과적으로 &lt;code>Argo&lt;/code> 도입은 적합하지 않다고 판단이 되었고 따라서 충분히 써볼 수는 없었기에 기록용으로만
간단히 적어보겠습니다.&lt;/p>
&lt;h2 id="argo-project-구조">Argo Project 구조&lt;/h2>
&lt;blockquote>
&lt;p>Argo가 워낙 빠르게 변화하는 서비스다보니 지금은 구조가 많이 변경되었을 수도 있습니다!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_1.png"
width="821"
height="907"
srcset="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_1_hu09fc34dc1feead582202ec3daf6e4c38_119738_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_1_hu09fc34dc1feead582202ec3daf6e4c38_119738_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="argo_1"
class="gallery-image"
data-flex-grow="90"
data-flex-basis="217px"
>&lt;/p>
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_2.png"
width="781"
height="601"
srcset="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_2_hu151253e02a61d15371380a76cade58b5_81692_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo_2_hu151253e02a61d15371380a76cade58b5_81692_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="argo_2"
class="gallery-image"
data-flex-grow="129"
data-flex-basis="311px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>간편하게 사용할 수 있는 순서는 &lt;code>argo&lt;/code>, &lt;code>argo&lt;/code>(workflow), &lt;code>argo event&lt;/code> 순이라고 생각되는데,
실질적인 파이프라인 구축은 &lt;code>argo event&lt;/code>, &lt;code>argo&lt;/code> (workflow), &lt;code>argo&lt;/code> 순으로 이뤄지는 셈이라 후자의
순서에 맞춰 설명해보겠습니다.&lt;/p>
&lt;h3 id="argo-event-official-sitehttpsargoprojgithubioargo-events">Argo Event (&lt;a class="link" href="https://argoproj.github.io/argo-events/" target="_blank" rel="noopener"
>Official site&lt;/a>)&lt;/h3>
&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo-events-top-level.png"
width="1243"
height="828"
srcset="https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo-events-top-level_hu911ca173f7b6efecb06ab37a91a70151_401443_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/argo-poc/argo-events-top-level_hu911ca173f7b6efecb06ab37a91a70151_401443_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="argo-events-top-level.png"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="360px"
>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>셋 중 가장 베이비 프로젝트입니다. 빠르게 개발되고 있고, 변화하고있기에 제가 &lt;code>argo&lt;/code> project들을 만났던
시절과 많이 구조가 달라져있습니다. 간단하게 말하자면 이벤트를 감지하여 어떤 작업을 수행할 수 있습니다.
&lt;code>argo-events&lt;/code>의 공식 홈페이지에서 제공되는 위의 이미지와 같이 다양한 이벤트 소스를 이용해 다양한 이벤트를
트리거할 수 있습니다. 예를 들어 &lt;code>AWS SQS&lt;/code>에 메시지가 생기면, 그 메시지를 가져와서 어떤 작업을 수행할 수 있습니다.
혹은 웹훅 서버를 돌려서 웹훅 요청이 오면, 어떤 작업을 트리거할 수 있습니다.&lt;/p>
&lt;p>제가 구상한 파이프라인에서는 이벤트를 감지하는 역할로서 Argo Events를 앞에 두고,
Argo Events가 Workflow를 생성는 작업을 트리거하는 방식으로 CI/CD에 이용할 수 있습니다.&lt;/p>
&lt;h3 id="argo-argo-workflow-official-sitehttpsargoprojgithubioargo">Argo, Argo Workflow (&lt;a class="link" href="https://argoproj.github.io/argo/" target="_blank" rel="noopener"
>Official site&lt;/a>)&lt;/h3>
&lt;p>셋 중 가장 오래된 프로젝트이고, 별도 많습니다. Argo 라는 이름을 가졌고 실질적으로는 Workflow 관련 프로젝트입니다.
&lt;code>Workflow&lt;/code>란 컨테이너를 이용해 진행되는 일련의 step들을 정의하는 CRD(K8s Custom Resource Definition 입니다.)&lt;/p>
&lt;p>처음엔 &amp;lsquo;굳이 Workflow가 필요할까&amp;rsquo; 싶었지만, 쿠버네티스 상에서 일련의 Job을 연속적으로 수행할 수 있는
방법이 현재까지는 없는 것으로 알고 있습니다.
K8s Job의 &lt;code>Container&lt;/code>에 대한 &lt;code>InitContainer&lt;/code>을 지정함으로써 한 Job에 대한 두 Container의 순서를
명시할 수는 있지만, &lt;code>Workflow&lt;/code>처럼 다양하게 일련의 Job을 연속적으로 수행하기는 힘든 것으로 알고 있습니다.&lt;/p>
&lt;h3 id="argocd-official-sitehttpsargoprojgithubioargo-cd">ArgoCD (&lt;a class="link" href="https://argoproj.github.io/argo-cd/" target="_blank" rel="noopener"
>Official site&lt;/a>)&lt;/h3>
&lt;p>&lt;code>ArgoCD&lt;/code>만 보면 가장 간단하게 실제 CD에 적용할 수 있는 프로젝트 중 하나가 아닐까싶습니다.
&lt;code>ArgoCD&lt;/code> 자체에 대한 설정, 소스가 될 Repository에 대한 설정, Project, Application에 대한 설정 등등
모든 것이 &lt;code>Code&lt;/code> IaC에 특화된 독특한 프로젝트입니다.&lt;/p>
&lt;p>UI가 직관적이고 알아보기 쉽지만, 반대로 대규모 애플리케이션이 될 경우 너무도 배포 현황을 보여주는 맵이 커지기 때문에
알아보기 쉽지 않을 수 있을 것 같습니다. &lt;code>GitOps&lt;/code>(&amp;ldquo;GitOps의 핵심은 Git 저장소에 저장된 쿠버네티스 매니페스트 같은 파일을 이용하여, 배포를 선언적으로 한다는 것입니다. &lt;a class="link" href="https://kangwoo.kr/tag/gitops/" target="_blank" rel="noopener"
>출처&lt;/a>&amp;rdquo;)
라는 말에 아마 빠지지 않고 등장하는 CD 도구인듯합니다. Git에 올라가는 Manifest가 그대로 K8s 클러스터에 적용됩니다.
마치 Github Page나 S3(웹호스팅 설정이 된 S3 Bucket)에 올린 파일들이 바로 하나의 웹 애플리케이션처럼 동작하는 것과 비슷한 느낌입니다.
간단하게 사용하기에는 ArgoCD가 참 좋아보였지만, 실제로 업무적으로 사용하지는 못하겠다고 판단한 이유가 몇 가지 있습니다.&lt;/p>
&lt;ul>
&lt;li>애플리케이션 하나에 대한 배포는 쉽지만, 연속적인 배포나 다양한 배포 파이프라인을 구성하기는 어려웠다.&lt;/li>
&lt;li>Github Push 시에 webhook을 설정해서 &lt;code>ArgoCD&lt;/code>의 배포를 트리거하도록 했는데 이 부분이 최적화가 덜 되었는지
어떤 repository든 하나의 ArgoCD 환경에서는 Git platform 당 하나의 secret만 설정이 가능했고, 한 repository가 push되면
다른 repository도 배포가 다 같이 이루어져버렸습니다. (이 부분은 패치됐을 수도 있습니다.)&lt;/li>
&lt;li>소규모 애플리케이션은 배포 상황을 한 눈에 보기 쉽지만, K8s Object가 많아지면 많아질수록
점점 하나하나 눈에 보이지 않고, 잡다한 Object들(ConfigMap, Secret, &amp;hellip;)로 인해 인식하기 힘듭니다.&lt;/li>
&lt;/ul>
&lt;h2 id="argo-project를-조합한-cicd-파이프라인-구축기">Argo Project를 조합한 CI/CD 파이프라인 구축기&lt;/h2>
&lt;h3 id="파이프라인-수행-과정">파이프라인 수행 과정&lt;/h3>
&lt;ol>
&lt;li>(&lt;code>Argo Event&lt;/code>) Github Push를 감지하고 &lt;code>Argo Workflow CRD&lt;/code>를 생성
&lt;code>Argo workflow&lt;/code>를 통해 다양한 step들을 이용하기 위해 바로 &lt;code>ArgoCD&lt;/code>가 Github Push를 받지 않고,
&lt;code>Argo Event&lt;/code>가 받도록 했습니다.&lt;/li>
&lt;li>&lt;code>Argo Workflow&lt;/code>의 step들 수행
&lt;ul>
&lt;li>Slack에 workflow 시작 알림&lt;/li>
&lt;li>Experiment 환경에 배포 (Argo CD 이용)&lt;/li>
&lt;li>Interation Test 실행 트리거 (Jenkins 이용)&lt;/li>
&lt;li>Integration Test 결과가 성공이면 Dev 환경에 배포 (Argo CD 이용)&lt;/li>
&lt;li>어느 step에서든 실패 시 Slack에 실패 알림&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>이 정도 Pipeline을 짜면 사실 사용할 정도는 될 수 있겠지만, &amp;ldquo;일&amp;quot;로서 본다면 굳이 현재 사용 중인
Spinnaker에 비해 장점이 뚜렷하게 느껴지지 않는 Argo를 위해 파이프라인을 이전하기에는 역부족이라는
판단이 들었습니다. 예를 들어 과정 목록에서는 간단히 묘사했지만, Spinnaker에서는 UI에서 알아서 처리되던
부분들을 하나 하나 webhook을 걸어주거나, 따로 bash script를 짜야하는 경우들이 많았습니다.&lt;/p>
&lt;h2 id="argo-project들에-대한-poc를-진행하며-느낀-점">Argo Project들에 대한 PoC를 진행하며 느낀 점&lt;/h2>
&lt;p>개인적으로는 많이 애정이 갔던 프로젝트들이고 신기했던 배포방식에 대한 소개였으며, 이 프로젝트들을
공부해보면서 다양한 아키텍쳐에 대해 경험해볼 수 있었던 것 같지만, 현실적인 벽에 부딪혀 도입을
할 수 없었던 아쉬움 컸습니다. 마치 좋아하는 분야가 있었지만, 현실의 벽에 부딪혀 꿈을 접고, 어떠한
현실적인 진로 나아가는 것과 같았달까요?&lt;/p>
&lt;p>그리고 개인적인 아쉬움은 위의 차트를 손수 그리며 PoC 문서를 작성했었지만, 결국은 PoC를 진행한
담당자인 저조차 &amp;ldquo;음&amp;hellip; 실사용은 힘들 것 같은데요&amp;quot;라는 의견을 냈던 터라 바쁜 일정 속에서
reject할 개념 증명 리뷰에 많은 시간을 할애할 수 없었기에, 팀원들과 이 내용을 공유할 수 없었던 점에
조금 아쉬움이 남습니다..! 만약 정말 &lt;code>Argo&lt;/code>를 사용하는 방식이 뛰어난 방식이었다면, 저도 적극 추천하며
함께 리뷰해주길 기대했겠지만, 현실적으로 저희 팀의 배포 방식과는 맞지 않았다고 판단해서 그랬던 것이기에
괜찮습니다~!&lt;/p></description></item><item><title>4. SpaceONE Helm Chart 개발</title><link>https://umi0410.github.io/blog/megazone-cloud/spaceone-helm/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/spaceone-helm/</guid><description>&lt;p>&lt;img src="https://umi0410.github.io/blog/megazone-cloud/spaceone-helm/spaceone-helm-preview.png"
width="1000"
height="802"
srcset="https://umi0410.github.io/blog/megazone-cloud/spaceone-helm/spaceone-helm-preview_hua20648dff267d17bdc5ba51e055b8d26_129267_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/megazone-cloud/spaceone-helm/spaceone-helm-preview_hua20648dff267d17bdc5ba51e055b8d26_129267_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="spaceone-helm-preivew.png"
class="gallery-image"
data-flex-grow="124"
data-flex-basis="299px"
>&lt;/p>
&lt;h2 id="spaceone-helm-chart란">SpaceONE Helm Chart란?&lt;/h2>
&lt;p>&lt;a class="link" href="https://github.com/spaceone-dev/spaceone-helm" target="_blank" rel="noopener"
>spaceone-helm&lt;/a> 은 저희
&lt;code>CloudOne&lt;/code> 팀이 개발하는 서비스인 &lt;a class="link" href="https://spaceone-dev.github.io/" target="_blank" rel="noopener"
>SpaceONE&lt;/a>을
&lt;code>helm chart&lt;/code>를 이용해 패키지화하는 프로젝트입니다. 원래의 저희 환경은 MicroService들을
개별 배포하고있었지만 오픈소스로 개발되는 저희 서비스를 저희 팀원들 뿐만아니라 다른
개발자들이 쉽게 개발할 수 있고, SpaceONE을 모르던 사용자들도 쉽게 SpaceONE을 구축해볼
수 있도록 하기 위해 패키지화도 진행하게되었습니다.&lt;/p>
&lt;p>일반적으로 만들어진 Helm Chart를 이용해보기만했지 직접 Chart를 만드는 것은 처음 해본 일이기도 했고,
Chart를 개발하면서 새로운 환경에 저희 서비스를 배포해보다보니 삽질하며 고생도 꽤 했고,
무엇보다 프로젝트의 시작부터 퇴사 전까지의 작업들을 거의 제가 도맡아한 프로젝트였기에 개인적으로
애정이 많이 갔습니다 ^_^! 그리고 저도 이제는 저희 Chart를 이용해 SpaceONE을 구축형으로
손쉽게 이용할 수 있었습니다.&lt;/p>
&lt;h2 id="spaceone-helm-설계">spaceone-helm 설계&lt;/h2>
&lt;p>일단은 심플하게 사이드카 없이 저희의 마이크로서비스들만을 배포하고, 그 외에 필요한 서비스들도 최대한
Cloud Service에 의존하지 않고 그때 그때 손쉽게 서비스를 내렸다 올렸다 할 수 있도록 K8s 클러스터 위에
함께 배포하는 형식으로 Chart를 설계했습니다.&lt;/p>
&lt;p>무엇보다 chart 개발의 목적은 아래 두 가지 사항이 컸기 때문에, &lt;code>minikube&lt;/code> 혹은 &lt;code>EKS&lt;/code> 띄운
마이크로서비스들과 로컬에서 통신이 가능하도록 해야했고, 사용하기 편리한 구조를 만들기 위해
고심했습니다.&lt;/p>
&lt;ul>
&lt;li>팀원이 아닌 개발자들도 자신의 부가적인 마이크로서비스를 로컬에 띄워 개발할 수 있도록 지원.
&lt;ul>
&lt;li>로컬에서도 쿠버네티스 클러스터 내의 서비스에 접속이 가능해야하고, 경우에 따라 클러스터에서도
본인의 로컬 서비스로 접속을 할 수 있어야함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오픈소스로서 임의의 사용자가 서비스를 구축해보고자 시도할 때 손 쉽게 구축할 수 있도록 지원.
&lt;ul>
&lt;li>마치 유저들의 사용자 경험을 중요시해서 디자인, 기획을 하듯 Chart의 사용자들이 직관적이고
편리하게 구축할 수 있도록 Configuration values(&lt;code>values.yaml&lt;/code> in Helm Chart)를 설계함.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="spaceone-helm-chart-구조">spaceone-helm chart 구조&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">templates/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── backend
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── config
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── config-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── config-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── config-svc.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── identity
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── identity-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── identity-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── identity-svc.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── inventory
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── inventory-svc.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── inventory-scheduler
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-scheduler-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-scheduler-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── inventory-scheduler-svc.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── inventory-worker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-worker-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   ├── inventory-worker-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   │   └── inventory-worker-svc.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#... Backend 생략&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── consul, mongo, redis &lt;span class="c1"># 디테일한 파일구조는 생략&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── frontend
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── console &lt;span class="c1"># 디테일한 파일구조는 생략&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── console-api &lt;span class="c1"># 디테일한 파일구조는 생략&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── ingress
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── ingress.yaml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">├── initializer
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── initialize-spaceone-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── initialize-spaceone-job.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   ├── spacectl-apply-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│   └── spacectl-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── supervisor
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── supervisor
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── supervisor-conf.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── supervisor-deployment.yml
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── supervisor-roles.yml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>저희 &lt;code>spaceone-helm&lt;/code> chart는 꽤나 구조가 간단한 편은 아니라고 생각됩니다. 웹페이지 환경상 너무
부수적인 부분은 tree에서 생략하기도 했습니다. 꽤나 복잡한 구조를 가졌기에 패키지화하는 부분이 쉽지 않았지만,
그런 과정 속에서 많이 트러블 슈팅을 경험하고 성장할 수 있었던 것 같습니다.&lt;/p>
&lt;p>그리고 반대로 생각하면, 서비스가 패키지화하기도 쉽지 않을만큼 복잡한 구조를 가졌다면,
당연히 손수 배포하는 것은 그것보다 몇 배는 어려울 것이므로 누군가가 저희 서비스를 구축형으로 이용해주기 위해서는
패키지화가 필수라는 생각이 들었습니다.&lt;/p>
&lt;h2 id="마이크로서비스들의-버전-관리를-시작">마이크로서비스들의 버전 관리를 시작&lt;/h2>
&lt;p>Helm Chart를 개발하고, CI가 고도화되기 전까지는 단순히 팀 내에서 개발을 진행하면서
개발환경에 대한 배포는 &lt;code>latest&lt;/code> tag만을 이용해 자동으로 진행하고,
QA를 진행하면서 커밋을 멈추고, 그 시점에 빌드된 Docker image의 Tag를 바탕으로 상용 환경에도
배포를 하곤했습니다. 하지만, Chart에서도 tag를 &lt;code>latest&lt;/code>로 유지하거나 가독성이 좋지 않은 임의의
tag를 이용해 이미지를 제공하기는 힘들었고, 맞는 방향이 아니라고 생각했습니다.&lt;/p>
&lt;p>따라서 저희는 꼭 Helm을 통한 패키지 뿐만 아니라 롤백에 대한 안정성, 버전 간의 Update 내역 관리
등을 위해 &lt;code>{{MAJOR}}.{{MINOR}}.{{SPRINT_NUMBER}}-{{EXTRA_TAGS}}&lt;/code> 형태를 통해
버전을 관리하고자했습니다.&lt;/p>
&lt;h2 id="helm-chart를-통해-패키지화하며-느낀-점">Helm Chart를 통해 패키지화하며 느낀 점&lt;/h2>
&lt;p>Helm Chart를 통해 저희 서비스를 패키지화하기 전까지는 마이크로서비스 형태로 관리되는 서비스를
새로운 환경에 완전하게 구축한다는 것은 쉽지 않았습니다.
&lt;code>Container&lt;/code>라는 것이 ReadOnly 레이어로 이미 구성이 완료된 이미지를 바탕으로 생성되기 때문에
언제 어디서든 구동이 가능하다는 것이 장점이겠지만, 현실적으로는 환경에 따라 이것 저것 설정해줘야하는
것이 있었기때문입니다.&lt;/p>
&lt;p>이러한 난관들은 어떠한 변수처리와 자동화를 통해 해결할 수 있을텐데, 그러한 작업을 해준 녀석이 바로
&lt;code>Helm&lt;/code>이었고, 그때 그때 설정을 바꿈으로써 커스터마이징할 수 있다는 점이 알고는 있었습니다만 막상
저희 서비스에 도입해보니 꽤나 만족스러웠습니다.&lt;/p>
&lt;p>일화로 사내 네트워크가 막힌 상황에서도 받아놓은 이미지들만 있으면 네트워크 접속을 할 필요 없이
&lt;code>minikube&lt;/code>와 &lt;code>로컬 서버&lt;/code>를 이용해 minikube의 클러스터와 통신하면서 개발을 진행할 수도 있었습니다.&lt;/p>
&lt;p>누군가 제가 만든 서비스를 사용해준다는 것은 참 뿌듯한 일이었고, 앞으로도 저희 helm chart가 잘
발전되어 더욱 더 편리하게 구축할 수 있는 형태로 제공될 수 있기를 기대해봅니다!&lt;/p></description></item><item><title>5. SpaceONE CLI Client인 spacectl 설계 및 개발</title><link>https://umi0410.github.io/blog/megazone-cloud/spacectl/</link><pubDate>Fri, 04 Sep 2020 12:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/megazone-cloud/spacectl/</guid><description>&lt;h2 id="spacectl이란">spacectl이란?&lt;/h2>
&lt;h3 id="소개">소개&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/spaceone-dev/spacectl" target="_blank" rel="noopener"
>spacectl&lt;/a> 은 저희팀이 개발하는 서비스인 SpaceONE의 &lt;code>gRPC&lt;/code> API request를 CLI로
손쉽게 수행할 수 있도록 해주는 도구입니다. 파이썬을 통해 개발했고 &lt;code>Click&lt;/code> 이라는 모듈로 CLI 환경을
손쉽게 사용할 수 있었고, &lt;code>Jinja2&lt;/code>를 통해 상세한 Manifest 들에서 변수 치환, 분기 등을 수행할 수 있었습니다.&lt;/p>
&lt;h3 id="사용-예시">사용 예시&lt;/h3>
&lt;h4 id="a-simple-example">A simple example&lt;/h4>
&lt;p>간단하게 &lt;code>spacectl&lt;/code>이 어떤 식으로 이용되는 도구인지 예시를 보여드리겠습니다.
아래의 커맨드를 이용해 손쉽게 &lt;code>SpaceONE&lt;/code>의 다양한 마이크로서비스들의 API를 이용할
수 있습니다.&lt;/p>
&lt;pre tabindex="0">&lt;code>$ spacectl list domain
domain_id | name | state | plugin_id ...
domain-abc123abc | umi0410| ENABLED | ...
$ spacectl list server -p domain_id=domain-abc123abc
server_id | name | provider ...
server-abc123abc | foo | aws ...
&lt;/code>&lt;/pre>&lt;h4 id="apply-command">apply command&lt;/h4>
&lt;p>&lt;code>spacectl apply&lt;/code> command는 kubectl의 apply와 유사하게 없으면 만들고,
있으면 업데이트하고 혹은 단순히 어떤 API를 Execute하는 Task들의 플로우를 관리해주는
커맨드 입니다.&lt;/p>
&lt;blockquote>
&lt;p>아쉽게도 퇴사 전에 마무리를 짓지는 못했습니다. ㅜ.ㅜ
퇴사 전까지 진행한 작업은 일부 리소스에 대한 CRU(create, read, update),
대부분의 리소스에 대한 Excute(execute할 API를 설정)까지입니다.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># main.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">import&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">mongo.yaml&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 개별 yaml file에서는 terraform/ansible과 같이 수행할 Task들을 정의&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">root_domain.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">repository.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">var&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">domain_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">root&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">domain_owner&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">admin_username&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">admin_password&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">admin&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">$ spacectl apply main.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="설계를-하며-느낀-점">설계를 하며 느낀 점&lt;/h2>
&lt;p>이 프로젝트에 대한 실제 개발 업무 이전에는 꽤나 설계 업무가 많았습니다.
저는 그 동안은 혼자 주로 개발을 해왔고, 실행력 좋게 시작은 하지만 설계는 충분하지 않은 채
성급하게 실행에 옮겼던 경험이 많습니다. 또한 학생이었고, 개발 경력이 길지 않았기에
사실상 &amp;ldquo;개발 = 그때 그때 새로운 내용 공부&amp;quot;와 같은 느낌이었기에 애초에 설계를 하려해도 &lt;em>&amp;lsquo;뭐가
필요하고 뭐가 가능할 것이고 뭐가 힘들 것인가&amp;rsquo;&lt;/em> 를 판단하기 어려웠습니다.&lt;/p>
&lt;p>하지만 팀원들과 함께 개발하면서 밥 먹을 때, 회의 할 때 틈틈히 설계 방식과 요령에 대해
상의했고, 처음으로 설계를 어느 정도 굳힌 뒤 개발에 들어들어갔던 경험이었습니다.&lt;/p>
&lt;p>인턴 기간 막바지에 이 설계에 참여하게 된 것은 정말 값진 경험이었다고 생각했습니다.
사실 단순히 데브옵스로서 일할 때는 남들과 의사소통할 일이 그리 많진 않았는데, 이 설계를
맡게 되면서 많은 회의와 대화를 하게되었습니다.
선배 개발자분들과 설계에 대해 잦은 회의를 하면서 제가 &lt;strong>어떤 개발자가 되고싶은지&lt;/strong> 직접 느낄 수 있었던 것 같습니다.
그 배경에는 두 가지 충격이 있었습니다.&lt;/p>
&lt;ol>
&lt;li>&lt;em>&amp;lsquo;내가 남의 생각을 잘 읽는 편은 아니었나보군&amp;hellip;?&amp;rsquo;&lt;/em>&lt;/li>
&lt;li>&lt;em>&amp;lsquo;선배 개발자분은 내가 개판으로 설명해도 어떻게 귀신같이 나보다 내 생각을 잘 읽으시지?&amp;rsquo;&lt;/em>
=&amp;gt; 마치 축구할 때 노련한 축구선수와 함께 뛰면서 저 행동을 귀신같이 예측하고서는 너무나도 잘 밀어주는 느낌을 받았습니다&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>제가 평소에 말을 잘하는 편이라고 생각했는데, 남의 생각을 이해하고 읽어내는 능력은 그리 뛰어나지많은
않구나라는 생각을 하게됐습니다. 설계 내용이 꽤나 추상적으로 구두로 진행되었기에 그랬을 수도 있겠지만,
큰 충격은 선배 개발자분의 &lt;strong>노련함&lt;/strong>이었습니다.&lt;/p>
&lt;p>후에 누군가 어떤 개발자가 되고싶냐, 협업할 때 어떤 노하우가 있느냐 이런 내용을 물어보면
자신있게 &lt;strong>남의 생각을 잘 이해하고, 알아주는 사람&lt;/strong>과 관련해 대답할 수 있는 사람이 될 수 있었으면
좋겠습니다.&lt;/p>
&lt;p>또한 설계 깊게 진행하기 전에 침착하게 자료 조사를
잘 해야한다는 것을 느꼈습니다.&lt;/p>
&lt;p>하나 일화로 원래는 설정 파일에서 &lt;code>${{ tasks.umi0410.output }}&lt;/code> 이런 식의 변수를 이용한
설정을 치환한 뒤 API를 수행해야할 때, 아마 template 언어들을 제가 원하는 대로 사용하기
힘들 것이라 생각하고, 하나하나 함수와 클래스를 만들어가곤했는데, 개발이 거의 완료되어갈쯤
&lt;code>Jinja2&lt;/code>의 사용법을 다시 읽다보니 &lt;code>spacectl&lt;/code>에 &lt;code>Jinja2&lt;/code>를 적절히 사용할 수 있을 것 같았고,
정신이 번뜩 들어 몇 시간만에 수작업으로 짠 코드들을 덜어내고 Jinja2를 이용해 좀 더 깔끔하게
변수 치환 및 추가로 &lt;code>Jinja2&lt;/code>의 built-in filter들을 이용할 수 있었습니다!&lt;/p>
&lt;h2 id="개발하면서-느낀-점">개발하면서 느낀 점&lt;/h2>
&lt;p>역시 개발은 남이 만든 패키지를 잘 사용해야한다는 것을 느꼈고, 그냥 복사 붙여넣기만 잘하면 된다는 의미가 아니라,
그런 것들을 빠르게 가져와서 적용시키고 부분 부분 커스터마이징하기 위해서는
기본기가 탄탄해야한다고 느꼈습니다. 물론 수작업으로 만드는 것도 좋을 수 있겠지만, 다양한 엣지케이스가 존재할 수 있고,
그 모든 작업들을 문서로 상세히 설명하는 것이 아니라면, 제작자인 제가 아닌 누군가가 그 기능을 이용하기는
힘들 것입니다. Jinja2를 이용한 템플릿 기능 제공이 이와 관련된 경험이 될 수 있겠습니다.&lt;/p>
&lt;p>또한 남의 코드를 자세히 읽어보는 게 처음이었는데, 덕분에 파이썬 프로젝트를 수행할 때 어떤 식으로
디렉토리 스트럭쳐를 짜면 좋을 지 생각해볼 수 있었던 계기였던 것 같습니다.
제가 설계하고, 개발한 내용을 짧게나마 발표한 뒤 리뷰를 받고 수정을 하면 한층 더 코드의
구조와 사용이 간결하고 직관적으로 보인다는 느낌을 받을 수 있었습니다. 이렇게 다양한
가르침을 주신 &lt;strong>저희 팀의 선배 개발자분들께 항상 감사드립니다.&lt;/strong>&lt;/p>
&lt;p>Megazone CloudOne 팀의 DevOps 인턴으로서 근무했던 내용에 대한 후기가 거의 끝났습니다.
끝으로 인턴 활동에 대한 종합적인 느낀점을 이어서 보시거나 다시 목차를 보고싶으신 분은 &lt;a class="link" href="../index" >&lt;strong>여기&lt;/strong>&lt;/a>를
클릭해주세요.&lt;/p></description></item></channel></rss>