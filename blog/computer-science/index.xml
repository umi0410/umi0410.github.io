<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Science on Jinsu Playground</title><link>https://umi0410.github.io/blog/computer-science/</link><description>Recent content in Computer Science on Jinsu Playground</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 04 Sep 2020 11:27:30 +0900</lastBuildDate><atom:link href="https://umi0410.github.io/blog/computer-science/index.xml" rel="self" type="application/rss+xml"/><item><title>(도서) "NoSQL 철저 입문" - Column-Family DB, Graph DB</title><link>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-3/</link><pubDate>Thu, 17 Mar 2022 03:30:00 +0900</pubDate><guid>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-3/</guid><description>&lt;img src="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-3/cassandra-modeling.png" alt="Featured image of post (도서) "NoSQL 철저 입문" - Column-Family DB, Graph DB" />&lt;h1 id="시작하며">시작하며&lt;/h1>
&lt;p>저번 편에서는 Key-Value DB와 Document DB를 정리해봤고 이번 편에서는 Column Family DB와 GraphDB에 대해 정리해보려한다.&lt;/p>
&lt;p>Column Family DB나 GraphDB는 실제로 사용해본 적이 한 번도 없어서 어떤 녀석들인지 자세히는 모르지만 책 내용 위주로 정리해보도록 하겠다.&lt;/p>
&lt;h1 id="column-family-db">Column-Family DB&lt;/h1>
&lt;p>Column-Family DB는 한 Row에 무수히 많은 Column을 Schema가 강제되지 않은 형태로 이용할 수 있는 NoSQL의 한 종류이다. Wide column DB, Wide column store, Columnar DB 등의 다른 다양한 명칭들도 존재는 하지만 책에서는 좀 더 여러 컬럼을 묶어서 생각할 수 있는 점이 강조되는 Colum-Family DB라는 용어를 이용했다고 한다.&lt;/p>
&lt;p>Column-Family DB는 다른 일반적인 NoSQL과 관계형 데이터베이스의 사이의 그 무언가 같은 느낌인데 이는 NoSQL임에도 관계형 데이터베이스와 비슷한 몇 가지 특징들이 있기 때문이다.&lt;/p>
&lt;ul>
&lt;li>SQL과 유사한 쿼리 언어를 제공하기도 한다.&lt;/li>
&lt;li>Row와 Column 등의 개념이 존재한다.&lt;/li>
&lt;/ul>
&lt;p>그 외의 특징은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>자주 함께 사용되는 Column들을 묶어 Column family로 이용할 수 있다.&lt;/strong>&lt;/li>
&lt;li>Column family는 약간 RDB에서의 하나의 Table 같은 느낌으로 볼 수도 있다.
&lt;ul>
&lt;li>개인적으로는 Column family DB에서 하나의 Row에 해당하는 데이터들은 이미 JOIN이 수행된 데이터들의 모임 같다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사실 &lt;strong>2차원적인 테이블이 아닌 중첩된 맵 구조&lt;/strong>이다.
&lt;ul>
&lt;li>&lt;code>SortedMap&amp;lt;Row Key, SortedMap&amp;lt;Column Key, Column Value&amp;gt;&amp;gt;&lt;/code> 같은 느낌으로 볼 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단일 Row에 대한 전체 데이터들은 디스크에 저장될 때 서로 인접하지 않을 수도 있다.
&lt;ul>
&lt;li>하지만 하나의 Column-Family에 대한 데이터들은 인접해서 저장된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Schema가 강제되진 않음.&lt;/li>
&lt;li>&lt;strong>JOIN을 지원하지 않는 것 같다.&lt;/strong>&lt;/li>
&lt;li>&lt;strong>엄청나게 많은 데이터, 높은 확장성, 높은 가용성에 특화&lt;/strong>된 듯하다.&lt;/li>
&lt;li>컬럼값들의 버전 관리가 가능하다.&lt;/li>
&lt;/ul>
&lt;p>확장과 가용성에 특화된 DB이다보니 마스터가 SPOF (단일 실패 지점)이 될 수 있는 형태를 지양한 듯하고, Column-Family DB는 P2P 형태로 어느 누구 하나가 마스터이지 않고 평등하다.&lt;/p>
&lt;p>따라서 클러스터 내 서버들의 상태 공유, 데이터 최신화 및 복제 등 기존에 마스터가 수행하던 작업을 동료 Node들끼리 알아서 수행해야하고 그를 위한 커뮤니케이션이 필요한데 이때 동료 Node들이 많아질 수록 커뮤니케이션이 기하급수적으로 늘어날 수 있다. 이런 커뮤니케이션을 효율적으로 하기 위한 프로토콜들도 생겨나게 됐다. 간략히만 정리해보자면 그 중 하나가 “가십 프로토콜”이며, “각 노드가 다른 모든 노드들의 상태를 직접 체크하는 게 아니라 각자가 몇 몇 노드의 상태를 직접 체크하고 나머지 노드의 상태는 서로 주고 받은 정보를 참고한다” 정도로 정리해볼 수 있을 것 같다.&lt;/p>
&lt;p>Column-Family DB는 주로 빅데이터 분야에서 많이 쓰이는 것 같고, 빅데이터를 다룰 때에는 다음과 같은 작업들이 필요하다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ETL&lt;/code> (Extract, Transfrom, Load) - 데이터의 추출, 적절한 형태로 가공, 적재&lt;/li>
&lt;li>데이터 분석&lt;/li>
&lt;li>DB 성능 모니터링&lt;/li>
&lt;/ul>
&lt;p>Column-Family DB는 위와 같은 기능들을 잘 제공하고 있다. 반면 주로 제품(비즈니스) 로직을 위한 데이터 저장은 관계형 데이터베이스, Key-Value DB, 문서 DB를 많이 이용하는 것 같기는 하다.&lt;/p>
&lt;p>하지만 간단히 정리하려다가 다시 궁금증이 생겨서 자료를 좀 찾아보던 중 컬럼 패밀리를 제품 로직에서 사용하는 케이스에 관해 &lt;a class="link" href="http://hochul.net/blog/cassandra-data-modeling-best-practices-part-1/" target="_blank" rel="noopener"
>eBay의 상품 좋아요 기능을 Cassandra를 기준으로 데이터 모델링하는 것 관련 좋은 글&lt;/a>을 발견하게 되어 이 글을 참고해보면 좋을 것 같다. 요약은 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>요구되는 &lt;strong>조회 패턴을 근거로 올바른 수준의 비정규화&lt;/strong>를 하는 것이 중요하다.&lt;/li>
&lt;li>너무 정규화 되어있으면 필요한 정보를 찾기 위해 한 번 더 조회가 필요할 수 있고 비효율적이다.&lt;/li>
&lt;li>너무 비정규화 되어있으면 불필요하게 수많은 데이터가 중복되게 되고, 수정 사항 반영이 쉽지 않을 수 있다.&lt;/li>
&lt;/ul>
&lt;h1 id="graph-db">Graph DB&lt;/h1>
&lt;p>GraphDB는 로우, 컬럼 등을 바탕으로 데이터를 모델링하는 대신에 노드(혹은 정점, Vertex)와 관계(Relation 혹은 Edge)를 통해 데이터를 모델링한다. 이때 Edge는 방향이 있을 수도 있고, 없을 수도 있다.&lt;/p>
&lt;p>서로 많은 관계를 맺는 케이스에 사용하기 좋은 듯한데, 예를 들면 SNS의 유저 간의 친밀도, 네트워크에서 도시 간의 소요 시간 등을 나타내기 좋다.&lt;/p>
&lt;p>Graph DB에서 모델링할 수 있는 그래프와 그 예시는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>방향 그래프 - 조직 구성원의 상하 관계&lt;/li>
&lt;li>무방향 그래프 - 조직 구성원의 협력 관계&lt;/li>
&lt;li>유동 네트워크 (Flow network) - 도로 시스템, 교통 네트워크. (잘 모르겠습니다.)&lt;/li>
&lt;li>이분 그래프 - 각 연결 관계들을 따라 가면 두 개의 집합으로 번갈아 표현되는 그래프
&lt;ul>
&lt;li>e.g. 유저 - 게시글의 좋아요 관계
&lt;ul>
&lt;li>유저 - 게시글 - 유저 - 게시글 - &amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>e.g. 선생님과 학생의 관계
&lt;ul>
&lt;li>선생님 - 학생 - 선생님 - 학생 - &amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다중 그래프 - vertex ↔ vertex 간에 여러 edge가 존재할 수 있는 경우
&lt;ul>
&lt;li>e.g. 네비게이션&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>가중 그래프 - edge에 가중치가 존재하는 경우
&lt;ul>
&lt;li>e.g. 최단 경로 찾기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>그래프 DB를 언제 사용할 수 있을까?&lt;/strong>&lt;/p>
&lt;p>&lt;strong>항상 어떤 DB를 사용할 지, 어떻게 모델링할지는 사용하려는 패턴, 특히 조회 패턴에 근거해서 고려&lt;/strong>되어야한다.&lt;/p>
&lt;p>예를 들어 다음과 같은 조회 패턴을 가진 경우 그래프 DB를 사용하면 좋다.&lt;/p>
&lt;ul>
&lt;li>정점 A에서 정점 B로 가는 엣지는 몇 개인가?&lt;/li>
&lt;li>정점 A에서 정점 B로 가는 엣지 중 비용이 100 미만인 엣지는 몇 개인가?&lt;/li>
&lt;li>정점 A에서 정점 B로 가는 가장 효율적인 경로는 무엇인가?&lt;/li>
&lt;/ul>
&lt;p>좀 더 실생활과 밀접한 예시는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>유저 A와 친밀도가 높은 유저들은 누구인가?&lt;/li>
&lt;li>유저 A와 유저 B가 함께 아는 친구가 존재하는가?&lt;/li>
&lt;li>지역 A에서 지역 B까지 이동할 수 있는 경로가 존재하는가?&lt;/li>
&lt;/ul>
&lt;p>이렇게 &lt;strong>특정 엔티티를 기준으로 해당 엔티티와 엔티티와 다른 엔티티들의 연결 관계를 바탕으로 조회를 하는 경우 그래프 DB를 사용하면 좋다&lt;/strong>.&lt;/p>
&lt;p>반면, 다음과 같이 엔티티나 테이블 전체에 걸친 질의는 적합하지 않다.&lt;/p>
&lt;ul>
&lt;li>오늘 받은 좋아요가 가장 많은 게시글은 어떤 게 있는가?&lt;/li>
&lt;li>가장 연결된 경로가 많은 지역은 어디인가?&lt;/li>
&lt;/ul>
&lt;p>실제로는 Graph DB를 이용하는 유즈케이스는 다음과 같은 운송 회사가 있을 수 있다.&lt;/p>
&lt;p>&lt;strong>“제한 시간 내에 운송 가능한 최소 비용 경로를 찾기”&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>운송 소요 시간을 가중치로 한 출발 시설 ↔ 도착 시설 간의 연결 관계가 존재&lt;/li>
&lt;li>경로를 거쳐가던 중 제한 시간을 초과하게 되면 그 경로는 제외됨.&lt;/li>
&lt;li>그 외의 가능한 경로 중 가장 저렴한 경로를 채택!&lt;/li>
&lt;/ol>
&lt;h1 id="참고해보면-좋을-것-같은-링크">참고해보면 좋을 것 같은 링크&lt;/h1>
&lt;ul>
&lt;li>카산드라 데이터 모델링 part.2 - eBay의 좋아요 모델링 - &lt;a class="link" href="http://hochul.net/blog/cassandra-data-modeling-best-practices-part-1/" target="_blank" rel="noopener"
>http://hochul.net/blog/cassandra-data-modeling-best-practices-part-1/&lt;/a>&lt;/li>
&lt;li>Data modeling 관련 카산드라 문서 - &lt;a class="link" href="https://cassandra.apache.org/doc/latest/cassandra/data_modeling/index.html" target="_blank" rel="noopener"
>https://cassandra.apache.org/doc/latest/cassandra/data_modeling/index.html&lt;/a>
&lt;ul>
&lt;li>시간 나면 읽어보면 좋을 것 같다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>간단하게 Column-Family DB와 Graph DB에 대해 정리해봤다. 책 내용 외에도 위에 첨부한 eBay의 Cassandra 모델링 이야기가 꽤 재미있고, 평소 궁금했던 내용을 잘 알려준 것 같다. 책을 읽으면서 알게 됐지만 무심코 지나친 내용들이나 까먹은 내용들이 꽤 있었던 것 같은데 리뷰를 기회 삼아 한 번씩 다시 되돌아 볼 수 있는 것 같다.&lt;/p>
&lt;p>다음 책도 리뷰해보면 좋을 것 같다!&lt;/p>
&lt;p>이걸로 2022년 첫 책 리뷰 끝~!&lt;/p></description></item><item><title>(도서) "NoSQL 철저 입문" - Key-Value 데이터베이스, 문서 데이터베이스</title><link>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/</link><pubDate>Sat, 12 Mar 2022 15:30:54 +0900</pubDate><guid>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/</guid><description>&lt;img src="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning.png" alt="Featured image of post (도서) "NoSQL 철저 입문" - Key-Value 데이터베이스, 문서 데이터베이스" />&lt;h1 id="도서-nosql-철저-입문---key-value-db-document-db">(도서) “NoSQL 철저 입문” - Key-Value DB, Document DB&lt;/h1>
&lt;h1 id="시작하며">시작하며&lt;/h1>
&lt;p>앞선 글에서는 “NoSQL 철저 입문”이라는 도서에 대한 총평과 NoSQL 데이터베이스들이 공통적으로 갖는 특징에 대해 알아봤다.&lt;/p>
&lt;p>이번 글에서는 NoSQL들 중에서도 Key-Value DB와 Document DB이 특히나 서로 유사한 형태를 띄는 것 같아 묶어서 정리해보려한다.&lt;/p>
&lt;p>추가적으로 각자의 고유한 특징은 아니더라도 공통적 특징일 수 있는 Master - Slave(read replica) 구조나 Partitioning, Sharding 등등에 대해서도 정리할 예정이다.&lt;/p>
&lt;h1 id="key-value-database">Key-Value Database&lt;/h1>
&lt;ul>
&lt;li>키와 값 뿐인 가장 간단한 형태의 NoSQL 종류이다.&lt;/li>
&lt;li>아주 단순한 조회만이 지원된다. 키를 통해서만 조회가 가능하다.
&lt;ul>
&lt;li>키를 알고 있다면 데이터를 바로 찾을 수 있지만 키가 없다면 풀서치를 해야할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Key-Value Database는 간단한 형태의 DB이기 때문에 테이블이나 그래프로 복잡한 관계를 나타내려는 경우에는 부적합하다. 단순 저장과 키를 바탕으로한 조회로 충분한 경우에 가볍게 사용하기 좋다.&lt;/p>
&lt;p>아무래도 단순함은 빠른 속도와도 연관이 되기 때문에 속도가 빠른 편이고 대표적인 예시가 Redis이다. 단순한 동작에 In-Memory Database라는 특징으로 인해 Redis는 엄청난 속도를 자랑한다.&lt;/p>
&lt;p>단, 메모리 같이 작은 크기의 저장소를 이용할 때는 저장소가 가득 차지 않도록 주의해야한다! 주로 이를 위해 주로 eviction policy라는 저장소가 가득 차기전에 데이터를 적절히 삭제하는 정책을 설정한다. 주로 인-메모리 저장소는 캐시로 사용되고, 캐시는 지역성을 근거로 하기 때문에 시간 지역성을 바탕으로한 LRU 관련 정책이 많이 사용된다.&lt;/p>
&lt;p>Key-Value DB는 Key를 바탕으로 조회가 가능하기 때문에 Key에 조회 조건이 포함되어야 한다. 만약 어떤 유저의 최근 알림 내역 정보를 Key-Value DB 중 하나인 Redis에 저장한다고 해보자.&lt;/p>
&lt;pre tabindex="0">&lt;code>recent_notifications:{{username}} = [{{json string}}, {{json stirng}}]
예를 들어 유저가 umi0410이라면
아래와 같이 Redis에 해당 유저의 최근 알림 내역 정보를 저장할 수 있을 것이다.
recent_notifications:umi0410 = [
&amp;#34;{\&amp;#34;id\&amp;#34;: 1, \&amp;#34;title\&amp;#34;: \&amp;#34;1번 알림입니다.\&amp;#34;}&amp;#34;,
&amp;#34;{\&amp;#34;id\&amp;#34;: 2, \&amp;#34;title\&amp;#34;: \&amp;#34;2번 알림입니다.\&amp;#34;}&amp;#34;
]
&lt;/code>&lt;/pre>&lt;p>위와 같이 데이터를 저장하면 읽을 때에도 특정 유저의 최근 알림 정보를 읽어올 수 있을텐데, 이때 앞서 언급했듯 Key만을 바탕으로 데이터를 조회하게 된다.&lt;/p>
&lt;p>RDB의 경우 주로 의미 없는 Auto Increment ID를 PK이자 Clustered Index로 설정하기 때문에 Write 시에 Auto Increment ID를 바탕으로 디스크에 데이터가 연속된 위치에 저장되도록 하는 편이다. RDB는 PK가 아니라도 다양한 조건으로 값을 검색할 수 있기 때문에 PK는 성능을 고려해 의미 없는 Auto Increment ID를 넣는 것이다.&lt;/p>
&lt;p>반면 Key-Value Database는 Key를 바탕으로 밖에 데이터를 조회할 수가 없기 때문에 Key (RDB의 PK와 유사하게 ID의 역할을 한다고 볼 수 있음)에 의미가 담겨야한다.&lt;/p>
&lt;ul>
&lt;li>🔵 Key가 &lt;code>recent_notifications:umi0410&lt;/code> 처럼 조회 목적에 부합하는 정보를 포함하는 경우 → umi0410 유저에 대한 데이터가 저장되는 key 값을 알 수 있기 때문에 직접 Key 값을 찍어서 데이터를 조회할 수 있음&lt;/li>
&lt;li>❌ Key가 &lt;code>recent_notifications:1&lt;/code> 처럼 의미 없는 숫자값인 경우 → umi0410 유저에 대한 데이터를 찾으려면 Full scan을 해야할 수 있음.&lt;/li>
&lt;/ul>
&lt;h2 id="key-value-database는-언제-사용하면-좋을까">Key-Value database는 언제 사용하면 좋을까?&lt;/h2>
&lt;p>책에 나온 Key-Value database 사용 예시를 다시 보니 별로 마음에 안 들어서 내 생각대로 적어보려한다. 기본적으로 Key-Value database는 Key만으로 조회 요구사항을 만족할 수 있어야한다.&lt;/p>
&lt;p>Redis와 같은 In-memory 데이터베이스의 경우에는 낮은 레이턴시가 중요하다거나 수명이 짧은 데이터에 주로 사용한다. 많이 봐왔던 케이스는 &lt;strong>캐시나 장바구니 정보, 세션 정보 등이 있는 것 같다.&lt;/strong>&lt;/p>
&lt;p>유저가 처음 앱에 접속할 때 필요할 만한 알림 개수나 피드 정보등을 캐시해두면 좀 더 빨리 유저에게 정보를 전달할 수 있을 것이다.&lt;/p>
&lt;p>장바구니나 세션 정보 같은 것들은 영구적으로 필요한 데이터가 아니면서 정합성이 엄청 중요하다거나 관계가 복잡한 데이터가 아니기 때문에 간단하게 Key-Value DB를 이용하면 좋을 것 같다.&lt;/p>
&lt;p>“Redis 장바구니”나 “Redis shopping cart”로 구글링하면 자료가 꽤 나와서 나중에 시간 되면 좀 더 찾아보고싶다.&lt;/p>
&lt;h1 id="document-database">Document database&lt;/h1>
&lt;p>Document DB는 Key-Value와 꽤나 유사하지만 Value의 형태가 단순한 값이라기보단 JSON이나 YAML, XML 같은 Semi structured(반정형) 형태를 띄는 데이터베이스를 말한다.&lt;/p>
&lt;p>문서는 Key-Value 쌍의 집합이라고 볼 수 있다. 따라서 데이터 형태가 단순하면 Key-Value DB를, 그보다 좀 더 복잡하면 Document DB를 사용하는 편이라고 한다. 여기에 추가적으로 클러스터가 훨씬 커지고, 한 Key에 관련된 정보가 방대해지면 Columnar DB를 도입하게 되는 것 같다.&lt;/p>
&lt;p>Document DB는 관계형 데이터베이스와도 유사한 개념을 갖기도 한다.&lt;/p>
&lt;ul>
&lt;li>관계형 데이터베이스에서는 Row, 문서 데이터베이스에서는 문서가 존재&lt;/li>
&lt;li>관계형 데이터베이스에서는 Row의 집합인 테이블, Document DB에서는 문서의 집합인 컬렉션이 존재&lt;/li>
&lt;li>단, 관계형 데이터베이스는 같은 테이블 내의 Row들이 모두 동일한 형태를 갖도록 스키마를 강제한다.&lt;/li>
&lt;li>문서 데이터베이스는 같은 컬렉션 내의 문서들이 얼마든지 다른 형태를 가질 수 있다!&lt;/li>
&lt;/ul>
&lt;p>Document DB는 Unstructured data가 아닌 그나마 조금은 구조가 존재하는 Semi structured data를 저장하기 때문에 좀 더 다양한 질의가 가능하다. 예를 들어 Key가 아닌 속성을 바탕으로도 질의를 할 수 있고, 인덱스를 걸 수도 있다.&lt;/p>
&lt;p>단 RDB와 마찬가지로 인덱스 설정을 너무 적게 하면 읽기 성능이 나빠질 수 있고, 인덱스 설정을 너무 많이 하면 쓰기 성능이 나빠질 수 있다.&lt;/p>
&lt;p>BI(Business Intelligence)나 일반적인 웹 서비스는 Write 보다 Read가 훨씬 많다. 반면 로그성 데이터들은 Write가 Read보다 훨씬 많다.&lt;/p>
&lt;p>만약 Read와 Write가 둘 다 많으면서도 짧은 Latency가 중요하다면 Write용으로는 단순 적재형 데이터베이스와 Read 용으로는 수많은 인덱스를 지원하기 용이한 데이터 웨어하우스 등을 이용하는 것이 좋다. 즉 어느 한 가지 DB만을 선택할 것이 아니라 각 DB를 각 필요한 상황에 적용할 수도 있다는 것이다. 주로 쓰기 작업에 최적화된 DB의 내용이 읽기 작업에 최적화된 DB로 전달되도록 구축한 뒤 쓰기 작업과 읽기 작업을 각각 다른 DB를 이용하는 형태가 많이 사용된다고 한다.&lt;/p>
&lt;h2 id="문서-db에서-관계-나타내기">문서 DB에서 관계 나타내기&lt;/h2>
&lt;p>RDB는 관계를 주로 테이블 간의 참조를 통해 나타낸다. 관계의 종류에는 1 대 1, 1 대 다, 다 대 다가 있다.&lt;/p>
&lt;ul>
&lt;li>1 대 1과 1 대 N 관계
&lt;ul>
&lt;li>1에서 완전히 상대 1이나 상대 N 을 완전히 서브 문서 형태로 정의를 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>M 대 N 관계
&lt;ul>
&lt;li>한 쪽이 한 쪽을 완전히 포함할 수는 없어 결국엔 두 개의 컬렉션이 필요하다.&lt;/li>
&lt;li>자신과 관련된 상대방 정보는 각자가 저장하기 때문에 양쪽에 데이터가 최신화되고 참조 무결성을 보장하도록 애플리케이션 레벨에서 잘 처리해야한다.&lt;/li>
&lt;li>책에는 자신과 관련된 상대 문서들의 ID를 리스트로 관리해 참조하도록 나와있는데 이 경우에도 중첩 문서의 형태로 나타낼 수는 있을 것이라 생각한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>간단히 Key-Value DB, Document DB에 대해 알아봤다. 이제는 NoSQL에서 노드의 역할은 어떤 것들이 있을지, 각 노드들은 어떤 데이터들을 어떤 로직에 의해 담당하게 되는지 정리해보려한다.&lt;/p>
&lt;h2 id="문서-db는-언제-사용하면-좋을까">문서 DB는 언제 사용하면 좋을까?&lt;/h2>
&lt;ul>
&lt;li>데이터 형태가 Key-Value에 저장할 정도로 간단하지는 않은 경우&lt;/li>
&lt;li>Key 만으로 조회 요구사항을 충족할 수 없는 경우&lt;/li>
&lt;li>ACID 트랜잭션까지는 필요하지 않은 경우&lt;/li>
&lt;li>데이터의 형태가 정형화되지 않고 조금씩은 달라서 Schema를 준수하기 힘든 경우&lt;/li>
&lt;li>관계형 데이터베이스로는 요청을 처리하는 한계가 있어 수평 Scale이 필요할 정도인 경우&lt;/li>
&lt;/ul>
&lt;p>요청이 쏟아지는 게 아니라면 사실 관계형 데이터베이스로 많은 상황들을 해결할 수 있고 그 경우 아직은 나는 관계형 데이터베이스를 사용하는 것을 선호한다. 아무래도 역사가 깊어서 레퍼런스도 많고 편리한 ORM 도구들도 많기 때문이다.&lt;/p>
&lt;p>하지만 &lt;strong>고정된 스키마를 준수하기 힘들거나 수평 scale이 필요한 경우에는 문서 DB를 사용하는 것이 더 적절하다&lt;/strong>. 예를 들면 게시판, 댓글, 채팅 메시지등이 될 수 있을 것 같다.&lt;/p>
&lt;p>반면 주문이나 결제 내역, 재고 상황 같은 데이터들은 ACID 트랜잭션이 필요할 수 있어 관계형 데이터베이스를 사용하는 게 좋을 것 같다.&lt;/p>
&lt;h1 id="rdb에서-많이-사용되는-마스터-슬레이브read-replica-구조">RDB에서 많이 사용되는 마스터-슬레이브(Read Replica) 구조&lt;/h1>
&lt;ul>
&lt;li>쓰기 권한이 있는 Master node는 여전히 한 대, Master node를 복제해 Read 요청만 처리하는 Replica는 여러 대 둘 수 있는 구조&lt;/li>
&lt;li>여러 서버를 하나의 서버처럼 사용할 수 있는 형태인 클러스터 형태 치고는 그나마 단순하다.&lt;/li>
&lt;li>쓰기에 비해 읽기 요청이 월등히 많은 경우 사용할 수 있다!&lt;/li>
&lt;li>노드 간 통신이 많이 필요 없고 주로 복제를 위해 마스터 ↔ 슬레이브간의 통신만 하면 되는 경우가 많다.
&lt;ul>
&lt;li>Columnar DB의 경우 다수의 마스터가 존재할 수 있고, 이 경우 상태 체크를 위해 다수의 마스터 노드 간에 통신이 필요하고, 이를 위해 “가십 프로토콜” 같은 프로토콜이 존재하기도 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>나는 AWS를 주로 사용해온터라 RDS를 다룰 때에는 Read replica 얘기가 빠짐 없이 등장해서 친숙했다. RDB는 원래 수평적 Scale이 힘든 편이다. 엄격히도 일관성을 중요시하다보니 분산 환경을 지원하지 않는 경우가 많은 것 같고(확실하진 않음 ㅎㅎ) 지원한다해도 노드 수가 증가함에 따라 성능도 선형적으로 증가하기는 힘들다. 그래도 RDB에서의 수평적 Scale에 대한 니즈도 많이 존재하다보니 요즘은 AWS에서도 Aurora에 Multi master 기능을 붙이거나 RDS에도 최대 15개 갈이의 Read Replica를 지원하기도 한다.&lt;/p>
&lt;p>하지만 아무래도 RDB의 엄격한 일관성이 갖는 한계를 완전히 떨쳐낼 수는 없기 때문일지 손가락 발가락 합쳐서 셀 수 있는 개수 정도 까지만 수평 Scale이 가능한 것 같다.&lt;/p>
&lt;p>그 개수를 NoSQL 중 하나인 Redis와 비교해보자. Redis의 경우는 1000개의 마스터 노드까지도 선형적으로 성능이 증가한다고 한다. 선형적인 증가를 조건으로 했을 때 최대 1000개의 마스터인 것이지 약 16,000여개의 마스터까지도 늘릴 수는 있긴하다. 게다가 각 마스터 노드에 대한 슬레이브까지 구성할 수 있으니 얼마나 확장성에서 차이가 나는지 어느 정도 실감할 수 있다.&lt;/p>
&lt;h1 id="파티셔닝-partitioning">파티셔닝 (Partitioning)&lt;/h1>
&lt;p>파티셔닝이란 무언가를 분리하는 작업을 말하는데 데이터베이스에서는 주로 데이터를 분리해서 저장하는 경우를 말한다.&lt;/p>
&lt;ul>
&lt;li>수직 파티셔닝 - 한 테이블을 여러 가상의 테이블로 분리해서 저장하는 것&lt;/li>
&lt;li>수평 파티셔닝 - partition key를 바탕으로 분산하여 그에 해당하는 값을 저장하는 것&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning.png"
width="1793"
height="1000"
srcset="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="파티셔닝 예시"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="430px"
>&lt;/p>
&lt;p>RDB에서는 주로 수직 파티셔닝만을 지원하고, NoSQL에서는 굳이 수직 파티셔닝을 이용하기보단 수평 파티셔닝을 이용하는 경우가 많다. (왜 NoSQL에서는 수평 파티셔닝을 잘 사용하지 않는지는 잘 모르겠다.)&lt;/p>
&lt;p>RDB에서는 수직 파티셔닝을 통해 자주 함께 접근하는 컬럼들은은 SSD 파티션에 저장하고, 잘 접근하지 않는 컬럼들은 HDD 파티션에 저장하는 것 같다.&lt;/p>
&lt;p>NoSQL에서는 주로 Partition key로 데이터가 저장될 노드가 결정되고 그 노드에 데이터를 저장한다.&lt;/p>
&lt;h2 id="샤딩-sharding">샤딩 (Sharding)&lt;/h2>
&lt;p>그중에서도 수평 파티셔닝은 샤딩이라는 또 다른 이름을 갖고 있다.&lt;/p>
&lt;p>&lt;img src="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/shard.png"
width="421"
height="234"
srcset="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/shard_hu1ff96d9a5545f8f306191c429eca38fc_36432_480x0_resize_box_3.png 480w, https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/shard_hu1ff96d9a5545f8f306191c429eca38fc_36432_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="AWS ElasticCache의 Shard. 출처: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Shards.html"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="431px"
>&lt;/p>
&lt;p>파티션 키(샤드 키)를 통해 그 키에 대한 데이터를 담당하는 노드 그룹을 샤드라고 하고, 한 샤드는 Primary 노드만 존재할 수도 있고 Read replica들도 존재할 수도 있다.&lt;/p>
&lt;p>그럼 파티션 키라는 놈을 바탕으로 데이터가 어디에 저장될 지를 구체적으로 어떻게 결정하는 걸까?&lt;/p>
&lt;ul>
&lt;li>&lt;code>Range Partitioning&lt;/code> - 파티션 키의 구간에 따라 어떤 노드가 담당할 지를 미리 선언해놓고, 이를 참조하여 샤드를 정한다.&lt;/li>
&lt;li>&lt;code>Hash Partitioning&lt;/code> - 파티션 키를 인자로 해싱 함수를 수행해 얻어지는 결과값을 샤드로 정한다.&lt;/li>
&lt;/ul>
&lt;p>주로 많이 사용되는 접근법은 Range 기반과 Hash 기반 두 가지이다.&lt;/p>
&lt;h2 id="range-partitioning">Range Partitioning&lt;/h2>
&lt;p>Range partitioning은 아래와 같이 미리 파티션 키의 구간에 따라 어떤 노드가 담당할지를 미리 선언해야한다. 샤드가 4개 존재한다고 하겠다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>id: 1&lt;/code> ~ &lt;code>id: 1000&lt;/code>은 1번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id: 1001&lt;/code> ~ &lt;code>id: 2000&lt;/code>은 2번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id: 2001&lt;/code> ~ &lt;code>id: 3000&lt;/code>은 3번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id: 3001&lt;/code> ~ &lt;code>id: 4000&lt;/code>은 4번 샤드가 담당&lt;/li>
&lt;/ul>
&lt;p>아주 &lt;strong>직관적이고 간단하다&lt;/strong>는 장점이 있다.&lt;/p>
&lt;p>하지만 &lt;strong>단점도 존재&lt;/strong>한다. &lt;strong>예상하지 못한 파티션 키(4000 &amp;lt; id)인 id: 4001인 데이터&lt;/strong>가 등장하게 되면 어떻게 될까? 올바르게 데이터를 저장하지 못할 수 있다.&lt;/p>
&lt;p>또한 1번, 2번 샤드는 비교적 오래된 유저에 대한 데이터이고 3, 4번 샤드는 최근 유입 유저에 대한 데이터라 각 샤드들에 대한 요청의 수가 상이하다면 어떻게 될까? &lt;strong>올바르게 요청이 분산되지 못하고 특정 샤드들에게만 집중될 수 있다&lt;/strong>는 문제가 있다.&lt;/p>
&lt;p>또한 결국은 어딘가에 이 Range 할당 정보를 저장하고 그것을 조회해야한다. 공통으로 필요한 데이터가 어느 한 곳에 저장되어야한다는 부분에서 요청이 증가하고 샤드도 확장되는 상황에서 이런 Range 할당 정보를 제공하는 측이 병목이 될 수도 있다.&lt;/p>
&lt;h2 id="hash-partitioning">Hash Partitioning&lt;/h2>
&lt;p>Hash partitioning은 Range partitioning과 달리 &lt;strong>어떤 샤드가 어떤 파티션 키를 담당하는지에 대한 매핑 테이블이 존재하지 않는다.&lt;/strong> 요청자측에서 &lt;strong>Hash 함수&lt;/strong>를 수행한 결과값으로 자신이 요청해야하는 노드를 유추할 수 있다.&lt;/p>
&lt;p>예를 들어 Range partitioning과 같이 샤드가 4개 존재한다고 해보자&lt;/p>
&lt;ul>
&lt;li>&lt;code>id % 4 == 1&lt;/code> 이면 1번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id % 4 == 2&lt;/code> 이면 2번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id % 4 == 3&lt;/code> 이면 3번 샤드가 담당&lt;/li>
&lt;li>&lt;code>id % 4 == 0&lt;/code> 이면 4번 샤드가 담당&lt;/li>
&lt;/ul>
&lt;p>클라이언트에 필요한 정보는 샤드 개수 뿐이다. id=4001인 데이터가 등장해도 4001 % 4는 1이므로 1번 샤드가 담당하면 된다.&lt;/p>
&lt;p>지금 예시에서는 Partition key가 id로 numeric한 값을 갖기 때문에 hash 함수를 거치지 않고 모듈러 연산만으로도 원활히 동작하는 것 같지만 실제로는 non-numeric한 값들에 대해서도 지원하고 골고루 데이터가 분산될 수 있도록 하기 위해 해싱 함수들을 사용한다.&lt;/p>
&lt;p>단 Hashing partitioning에도 단점이 존재하는데 바로 수평 Scale시에 각 샤드가 담당하는 데이터가 상이해질 수 있다. 예를 들면 노드가 2대 → 4대로 증가하는 경우를 예로 들어보겠다.&lt;/p>
&lt;ul>
&lt;li>기존 (노드 2대)
&lt;ul>
&lt;li>&lt;code>id = 1&lt;/code> → 1번 노드&lt;/li>
&lt;li>&lt;code>id = 2&lt;/code> → 2번 노드&lt;/li>
&lt;li>&lt;code>id = 3&lt;/code> → 1번 노드&lt;/li>
&lt;li>&lt;code>id = 4&lt;/code> → 2번 노드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>수평 Scale 후 (노드 4대)
&lt;ul>
&lt;li>&lt;code>id = 1&lt;/code> → 1번 노드&lt;/li>
&lt;li>&lt;code>id = 2&lt;/code> → 2번 노드&lt;/li>
&lt;li>&lt;code>id = 3&lt;/code> → &lt;del>1번 노드&lt;/del> 3번 노드&lt;/li>
&lt;li>&lt;code>id = 4&lt;/code> → &lt;del>2번 노드&lt;/del> 4번 노드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>위와 같이 데이터를 담당하는 샤드들이 많이 변경되어 rebalance가 필요하다는 어려움이 존재한다. 게다가 이 어려움은 Scale out 때 뿐만 아니라 Scale in 시에도 존재하기도 한다.&lt;/p>
&lt;p>이런 rebalance 과정을 좀 더 최적화하기 위해 consistent hashing이라는 개념이 존재하고 이에 대한 구현체로 virtual node들을 두는 ketama consistent hashing도 존재한다. 이에 대해서는 책에 깊게 등장하진 않고 구글링으로 많은 자료를 찾아볼 수 있기에 이번 글에서는 생략하도록 하겠다.&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>Key-Value 데이터베이스와 Document 데이터베이스의 특징에 대해 적어봤다.&lt;/p>
&lt;p>책 내용을 잊어버리기 전에 한 번 정리해보면서 복습하려했었는데 살짝 까먹어가던 내용이나 대충 읽고 넘어간 부분에 대해서도 점검해볼 수 있었던 것 같다.&lt;/p>
&lt;p>( &lt;strong>책 내용 뿐만 아니라 나중에 복습할 용도로 제가 기존에 알고 있던 내용이나 주관적인 의견들도 조금씩 적어놨습니다. 잘못된 내용이라 생각되는 부분이 있으시면 알려주시면 감사하겠습니다!&lt;/strong> )&lt;/p></description></item><item><title>(도서) "NoSQL 철저 입문" 후기 및 NoSQL의 공통적 특징</title><link>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-1/</link><pubDate>Fri, 11 Mar 2022 23:46:54 +0900</pubDate><guid>https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-1/</guid><description>&lt;img src="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-1/cover.jpg" alt="Featured image of post (도서) "NoSQL 철저 입문" 후기 및 NoSQL의 공통적 특징" />&lt;h1 id="책을-읽게-된-계기">책을 읽게 된 계기&lt;/h1>
&lt;p>당근마켓 플랫폼 팀의 서버 엔지니어로 지원하고 면접을 보면서 &lt;code>저장소&lt;/code>에 관련한 질문을 많이 받았었다. &lt;code>저장소&lt;/code>는 &lt;code>관계형 데이터베이스&lt;/code>나 다양한 &lt;code>NoSQL 데이터베이스&lt;/code>들을 의미한다고 할 수 있겠다.&lt;/p>
&lt;p>많은 질문들이 나왔고, 당시의 나는 사실 데이터베이스 쪽 지식은 거의 전무했던 것 같아 제대로 대답을 못한 게 많았던 것 같다. 인턴 근무를 하면서는 내가 익숙했던 관계형 데이터베이스가 아닌 NoSQL 특히 &lt;code>Redis&lt;/code>나 &lt;code>DynamoDB&lt;/code> 등을 주로 사용하는 모습도 많이 보게 되어 NoSQL에 대해 관심이 가게 되었다.&lt;/p>
&lt;p>&lt;em>‘왜 관계형 데이터베이스는 수평 Scale이 어렵다고들 하는거지?’&lt;/em>, &lt;em>‘왜 NoSQL은 수평 Scale이 용이하지?’&lt;/em>&lt;/p>
&lt;p>&lt;em>‘어떤 경우에 관계형 데이터베이스가 아닌 NoSQL을 사용하는 게 적절할까?’&lt;/em>&lt;/p>
&lt;p>&lt;em>‘정말 NoSQL이어야만하는 경우들이 존재할까?’&lt;/em>&lt;/p>
&lt;p>위와 같은 궁금증을 갖고 있었고, 그런 면에서 다양한 NoSQL 책들을 찾아보다가 하나의 NoSQL에 딥다이브하는 책보다는 &lt;strong>다양한 NoSQL 데이터베이스들이 어떤 특징들을 갖는지 비교해주고, 실제 사용 사례는 어떤 경우가 있을지를 알려주는 책&lt;/strong>을 읽어보고 싶었다.&lt;/p>
&lt;h1 id="nosql의-공통된-특징">NoSQL의 공통된 특징&lt;/h1>
&lt;p>&lt;code>Key-Value&lt;/code>, &lt;code>Document&lt;/code>, &lt;code>Column family (혹은 Columnar)&lt;/code> 류의 NoSQL 데이터베이스들에 대해서는 추후 각 글에서 정리하는 것으로 하고 이번 글에서는 좀 더 전반적인 NoSQL의 특징에 대해 정리하려한다.&lt;/p>
&lt;p>NoSQL은 관계형 데이터베이스가 아닌 데이터베이스들을 통칭하는 명칭이기 때문에 각각이 다양한 특징을 갖지만 탄생 목적 자체가 SQL 데이터베이스로 만족할 수 없는 유즈케이스를 위해서 였기 때문에 SQL 데이터베이스의 반대되는 쪽으로는 공통적인 특징을 갖는 편이다.&lt;/p>
&lt;p>&lt;strong>관계형 데이터베이스와 NoSQL은 절대적으로 누가 더 낫다를 비교할 존재라기 보단 각자가 적절한 목적을 갖는 상호 보완적인 존재이다!&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>Schemaless&lt;/code>&lt;/li>
&lt;li>&lt;code>ACID&lt;/code> 특성을 갖지 않는다.&lt;/li>
&lt;li>좀 억지 네이밍이긴 하지만 &lt;code>BASE&lt;/code> 특성을 기반으로 한다.&lt;/li>
&lt;li>&lt;code>Eventual consistency&lt;/code>&lt;/li>
&lt;li>분산 시스템, 고가용성, 대규모 트래픽&lt;/li>
&lt;li>정규화보단 비정규화와 중복&lt;/li>
&lt;/ul>
&lt;p>그럼 각 특징에 대해 알아보자.&lt;/p>
&lt;h2 id="schemaless">Schemaless&lt;/h2>
&lt;p>&lt;strong>관계형 데이터베이스는 고정된 테이블 스키마&lt;/strong>를 갖고, 모든 레코드는 그 스키마 구조를 따라야만한다. 그렇기 때문에 데이터 형태가 계속해서 변경될 수 있는 경우에는 불편할 수 있다. 데이터가 적을 때야 그냥 &lt;code>alter table ...&lt;/code> 로 스키마를 변경하면 그만이겠지만 데이터와 트래픽이 많은 실제 프로덕션에서는 이런 작업이 쉽지 않다.&lt;/p>
&lt;p>반면 거의 모든 &lt;strong>NoSQL 데이터베이스는 스키마를 강제하지 않고 자유롭게 저장&lt;/strong>할 수 있다.&lt;/p>
&lt;h2 id="acid-특성을-갖지-않는다">ACID 특성을 갖지 않는다.&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>A (Atomic)&lt;/strong> - 한 트랜잭션은 원자 단위로 전체 작업이 성공하거나 전체 작업이 실패해야한다. 부분 작업만 적용되어서는 안된다.
&lt;ul>
&lt;li>쉽게 말하면 0과 1의 이분법적 사고라고 볼 수 있다. 한 트랜잭션 내의 일부 작업만 수행한 애매한 상태는 존재해선 안된다!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>C (Consistency)&lt;/strong> - 데이터베이스에 저장된 데이터는 일관성을 가져야한다.
&lt;ul>
&lt;li>만약 트랜잭션이 적용되었는데 다음 Read 요청 시 해당 데이터가 아직 반영이 안되어있으면 안된다.&lt;/li>
&lt;li>만약 트랜잭션이 롤백되었는데 해당 데이터가 남아있는 상태가 존재하면 안된다.&lt;/li>
&lt;li>구글링하다보면 Consistency를 어떤 이유에서인지 column에 대한 제약 조건과 연관지어 설명하는 한국어 자료들을 많이 찾아볼 수 있는데 나는 이는 잘못된 설명이 아닌가 싶다.
&lt;ul>
&lt;li>특히 NoSQL의 Eventual consistency와 대조해보면 column에 대한 제약 조건으로 consistency를 설명하는 것은 더욱 더 잘못된 설명이라고 느껴지지 않나 싶다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>I (Isolation)&lt;/strong> - 트랜잭션 과정 중에는 서로 다른 트랜잭션 간에는 서로의 과정에 간섭할 수 없다.
&lt;ul>
&lt;li>Isolation은 절대적인 것은 아니고 필요에 따라 얼마나 트랜잭션을 골비시킬 것인지를 의미하는 isolation level을 조절할 수 있다.&lt;/li>
&lt;li>&lt;code>Read uncommited&lt;/code>, &lt;code>Read commited&lt;/code>, &lt;code>Repeatable read&lt;/code>, &lt;code>Serializable&lt;/code> 와 같은 Isolation level들이 존재한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>D (Durability)&lt;/strong> - commit된 트랜잭션은 시스템이 비정상적으로 종료되더라도 보존되어야한다.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>ACID&lt;/code>는 &lt;strong>관계형 데이터베이스에서 제공하는 트랜잭션을 지원하기 위해 가져야할 4가지 특성&lt;/strong>을 의미한다.&lt;/p>
&lt;p>&lt;code>NoSQL&lt;/code>은 보통 이런 &lt;strong>ACID 특성을 완벽히 제공하지는 않는다.&lt;/strong> NoSQL에도 트랜잭션이 존재하기는 하지만 아마 ACID 특성을 모두 만족하는 트랜잭션은 아닐 것이다.&lt;/p>
&lt;p>ACID 트랜잭션은 정말 엄격하게 일관된 데이터를 강제하기 때문에 이를 위해선 성능을 많은 부분 양보해야하고 분산 시스템에서는 특히 동작하기 힘들 수 있기 때문이다.&lt;/p>
&lt;h2 id="base-특성을-기반으로-한다">BASE 특성을 기반으로 한다.&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>BA (Basically available)&lt;/strong> - 고가용성을 가져야한다.&lt;/li>
&lt;li>&lt;strong>S (Soft state)&lt;/strong> - 유저의 명시적 명령 없이 데이터가 변경될 수 있다.
&lt;ul>
&lt;li>Eventual consistency에 의해 데이터가 덮어씌워질 수도 있고&lt;/li>
&lt;li>TTL에 의해 데이터가 사라질 수도 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>E (Eventual consistency)&lt;/strong> - 결과적으로는 일관성을 띈다.
&lt;ul>
&lt;li>그 과정 속에서 데이터가 일관되지 않은 상태도 존재할 수 있다.&lt;/li>
&lt;li>사실 Temporary inconsistency가 좀 더 와닿는 표현일 수도.. 포인트는 *‘결과적으로는 일관성을 갖긴 하는구나~’*가 아닌 &lt;em>‘일시적으로는 일관되지 않을 수도 있구나!’&lt;/em> 이다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>관계형 데이터베이스는 애초에 엄격하게 일관된 데이터들을 저장하기 위한 솔루션이기에 ACID를 지원하지만 &lt;strong>NoSQL은 그런 엄격함으로 인해 확장성이나 성능을 제한받지 않고자 탄생한 솔루션&lt;/strong>이다.&lt;/p>
&lt;p>여기서 말하는 &lt;strong>성능&lt;/strong>은 작은 데이터에 대한 성능을 의미하는 게 아니라 &lt;strong>대규모 데이터에 대해서도 준수한 성능&lt;/strong>을 내는 것을 말한다. 데이터가 많아질 수록, 요청이 많아질 수록 범용적인 수준의 서버로는 요청을 다 감당하기 힘든데 이렇게 되면 범용적인 수준의 &lt;strong>서버를 수평적으로 스케일&lt;/strong> 할 수 있어야 한다.&lt;/p>
&lt;p>또한 고가용성을 위해서도 수평적으로 스케일할 수 있어야한다. (관계형 데이터베이스의 경우 주로 백업 서버를 대기시켜놓는 이중화를 통해 고가용성을 지원한다.)&lt;/p>
&lt;p>하지만 단일 시스템이 아닌 &lt;strong>분산 시스템이 되게 되면 모든 노드들이 일관된 데이터를 갖기가 힘들어지는데 이로 인해 엄격한 일관성이 아닌 Eventual consistency&lt;/strong>를 제공하게 된다.&lt;/p>
&lt;p>방금 확장성이나 성능, 고가용성에 대한 흐름으로 나온 내용들이 CAP 이론과 관련된 내용이라고 볼 수 있다. CAP 이론에 대해선 따로 정리하지 않겠다.&lt;/p>
&lt;h2 id="정규화보단-비정규화와-중복">정규화보단 비정규화와 중복&lt;/h2>
&lt;p>나는 모 기업의 기술 면접에서 &lt;em>‘관계형 데이터베이스에서도 JOIN을 하지 말자는 주장을 내는 사람들도 있는데, 이유가 뭘까요?’&lt;/em> 라는 질문을 받은 적이 있었다. 앞서 말했듯 나는 데이터베이스 관련 지식이 많이 부족하기도 했기 때문에 질문에 대한 대답은 둘째치고 &lt;em>‘관계형 데이터베이스에서 JOIN을 쓰지 말자는 사람도 있나&amp;hellip;?’&lt;/em> 라는 생각 뿐이었다.&lt;/p>
&lt;p>계속 얘기하지만 관계형 데이터베이스는 일관되고 이상 현상이 없는 데이터들을 저장하기 위한 솔루션이다. 그리고 그를 위해 테이블 간의 관계를 나타낼 때 테이블을 정규화하고 참조한 뒤 조회할 때에는 필요한 정보들을 JOIN으로 가져온다. 하지만 &lt;strong>JOIN은 꽤나 비싼 작업&lt;/strong>이다.&lt;/p>
&lt;p>반면 &lt;strong>NoSQL은 어느 정도 데이터의 불일치를 허용&lt;/strong>하기도 하기 때문에 조회 시 JOIN을 수행하기 보다는 비정규화된 형태로서 중복으로 저장된 데이터를 조회하는 경우가 많다.&lt;/p>
&lt;p>개인적으로는 이렇게 &lt;strong>비정규화한 형태로 중복된 데이터를 저장하는 방식은 &lt;code>CQRS&lt;/code>와도 어느 정도 비슷한 형태&lt;/strong>를 갖지 않나싶다. CQRS에서는 데이터를 조작하는 Command 와 데이터를 조회하는 Query의 책임을 분리하는 형태로, Query하는 측에서는 자신들이 조회하기 용이한 형태인 고도화 된 뷰(비정규화된 데이터)로 데이터를 저장한다. 데이터의 원본은 Command를 담당하는 곳에 저장된다.&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이렇게 NoSQL의 공통된 특징에 대해 책에 등장한 내용과 약간의 개인적인 의견을 정리해봤다. 책이 담고 있는 내용은 꽤나 마음에 든다! 특정한 NoSQL 데이터베이스의 기능 자체를 줄줄이 소개하는 것이 아니라 실용적인 예시 상황과 함께 각각의 NoSQL과 RDB에 대한 비교를 해볼 수 있었다.&lt;/p>
&lt;p>별점을 준다면 4.5점 정도..? 0.5점은 좀 더 예시가 디테일하고 자세했으면 너무나 좋았을 것 같다. 예시가 아예 없는 것은 아니라 간간히 실제 유즈케이스들이 등장하긴 하지만 너무 간단하게만 짚고 넘어가서 조금 아쉬웠다.&lt;/p>
&lt;p>사실 저번 하반기부터 올해 상반기까지 내가 한 게 성장한 게 있나, 새로 배운 게 있나 싶었는데 문득 책을 읽게 된 계기를 회상해보니 저장소 측면에서는 많이 배워가고 있는 것 같아 다행이다.&lt;/p>
&lt;p>&lt;em>‘이런 데이터를 나타내려면 당연히 테이블을 이런 식으로 정규화해서&amp;hellip;’&lt;/em> 와 같이 단순히 관계형 데이터베이스에서 테이블을 설계하는 기본적인 원칙을 기반으로 한 관점이 아니라 &lt;em>‘이런 데이터는 관계형 데이터베이스가 아닌 이런 이런 NoSQL을 사용하면 더 적합할 것이고, 전체 데이터 조회용으론 이런 NoSQL을 사용하면 더 적합할 것 같다.’&lt;/em> 와 같이 탈 RDB적 관점도 어느 정도 장착하게 된 것 같아 시각이 좀 넓어지고 있는 듯하다.&lt;/p>
&lt;p>작년 2021년 회고에서 &lt;strong>2022년에는 짧은 아티클 뿐만 아니라 체계적인 정보를 담은 책을 통해서도 공부를 해보겠다는 결심&lt;/strong>을 했었는데 2022년 1월이 되자 마자 구매했던 2022년의 첫 책을 포기하지 않고 끝까지 읽게 되어 다행이다! 아마 다음 책은 Real MySQL이나 Spring Boot나 JPA 관련 책이 되지 않을지?! ㅎㅎ&lt;/p></description></item></channel></rss>