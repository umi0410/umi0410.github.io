<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="&#34;NoSQL 철저 입문&#34;이라는 책을 읽고 작성한 후기 시리즈의 두 번째 편 입니다.
Key-Value DB와 문서 DB를 비교해봤습니다.
또한 Master-Slave 구조와 Partitioning에 대해서도 정리해봤습니다. 
"><title>(도서) "NoSQL 철저 입문" - Key-Value 데이터베이스, 문서 데이터베이스</title><link rel=canonical href=https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="(도서) &#34;NoSQL 철저 입문&#34; - Key-Value 데이터베이스, 문서 데이터베이스"><meta property="og:description" content="&#34;NoSQL 철저 입문&#34;이라는 책을 읽고 작성한 후기 시리즈의 두 번째 편 입니다.
Key-Value DB와 문서 DB를 비교해봤습니다.
또한 Master-Slave 구조와 Partitioning에 대해서도 정리해봤습니다. 
"><meta property="og:url" content="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/"><meta property="og:site_name" content="Jinsu Playground"><meta property="og:type" content="article"><meta property="article:section" content="Blog"><meta property="article:published_time" content="2022-03-12T15:30:54+09:00"><meta property="article:modified_time" content="2022-03-12T15:30:54+09:00"><meta property="og:image" content="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning.png"><meta name=twitter:title content="(도서) &#34;NoSQL 철저 입문&#34; - Key-Value 데이터베이스, 문서 데이터베이스"><meta name=twitter:description content="&#34;NoSQL 철저 입문&#34;이라는 책을 읽고 작성한 후기 시리즈의 두 번째 편 입니다.
Key-Value DB와 문서 DB를 비교해봤습니다.
또한 Master-Slave 구조와 Partitioning에 대해서도 정리해봤습니다. 
"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://umi0410.github.io/blog/computer-science/book-review-nosql-introduction-2/partitioning.png"><link rel="shortcut icon" href=https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/241/whale_1f40b.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177403492-1","auto"),ga("send","pageview"))</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=East+Sea+Dokdo&family=Noto+Sans+KR:wght@400&display=swap" rel=stylesheet><style>@import 'https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css';:root{--body-background:#fafeff;--base-font-family:Pretendard, 'Noto Sans KR', sans-serif}.site-name{--site-name-font-family:'East Sea Dokdo', cursive;font-family:var(--site-name-font-family);font-size:3.2rem!important}.left-sidebar{--sidebar-avatar-size:200px}figure.site-avatar{margin-left:auto!important;margin-right:auto!important}</style></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://umi0410.github.io class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/computer-science/book-review-nosql-introduction-2/><img src=/blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_800x0_resize_box_3.png srcset="/blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_800x0_resize_box_3.png 800w, /blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_1600x0_resize_box_3.png 1600w" width=800 height=446 loading=lazy alt='Featured image of post (도서) "NoSQL 철저 입문" - Key-Value 데이터베이스, 문서 데이터베이스'></a></div><div class=article-details><header class=article-category><a href=/categories/%EB%8F%84%EC%84%9C/>도서</a>
<a href=/categories/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/>데이터베이스</a></header><h2 class=article-title><a href=/blog/computer-science/book-review-nosql-introduction-2/>(도서) "NoSQL 철저 입문" - Key-Value 데이터베이스, 문서 데이터베이스</a></h2><h3 class=article-subtitle>"NoSQL 철저 입문"이라는 책을 읽고 작성한 후기 시리즈의 두 번째 편 입니다.
Key-Value DB와 문서 DB를 비교해봤습니다.
또한 Master-Slave 구조와 Partitioning에 대해서도 정리해봤습니다.</h3><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Mar 12, 2022</time></footer></div></header><section class=article-content><h1 id=도서-nosql-철저-입문---key-value-db-document-db>(도서) “NoSQL 철저 입문” - Key-Value DB, Document DB</h1><h1 id=시작하며>시작하며</h1><p>앞선 글에서는 “NoSQL 철저 입문”이라는 도서에 대한 총평과 NoSQL 데이터베이스들이 공통적으로 갖는 특징에 대해 알아봤다.</p><p>이번 글에서는 NoSQL들 중에서도 Key-Value DB와 Document DB이 특히나 서로 유사한 형태를 띄는 것 같아 묶어서 정리해보려한다.</p><p>추가적으로 각자의 고유한 특징은 아니더라도 공통적 특징일 수 있는 Master - Slave(read replica) 구조나 Partitioning, Sharding 등등에 대해서도 정리할 예정이다.</p><h1 id=key-value-database>Key-Value Database</h1><ul><li>키와 값 뿐인 가장 간단한 형태의 NoSQL 종류이다.</li><li>아주 단순한 조회만이 지원된다. 키를 통해서만 조회가 가능하다.<ul><li>키를 알고 있다면 데이터를 바로 찾을 수 있지만 키가 없다면 풀서치를 해야할 수 있다.</li></ul></li></ul><p>Key-Value Database는 간단한 형태의 DB이기 때문에 테이블이나 그래프로 복잡한 관계를 나타내려는 경우에는 부적합하다. 단순 저장과 키를 바탕으로한 조회로 충분한 경우에 가볍게 사용하기 좋다.</p><p>아무래도 단순함은 빠른 속도와도 연관이 되기 때문에 속도가 빠른 편이고 대표적인 예시가 Redis이다. 단순한 동작에 In-Memory Database라는 특징으로 인해 Redis는 엄청난 속도를 자랑한다.</p><p>단, 메모리 같이 작은 크기의 저장소를 이용할 때는 저장소가 가득 차지 않도록 주의해야한다! 주로 이를 위해 주로 eviction policy라는 저장소가 가득 차기전에 데이터를 적절히 삭제하는 정책을 설정한다. 주로 인-메모리 저장소는 캐시로 사용되고, 캐시는 지역성을 근거로 하기 때문에 시간 지역성을 바탕으로한 LRU 관련 정책이 많이 사용된다.</p><p>Key-Value DB는 Key를 바탕으로 조회가 가능하기 때문에 Key에 조회 조건이 포함되어야 한다. 만약 어떤 유저의 최근 알림 내역 정보를 Key-Value DB 중 하나인 Redis에 저장한다고 해보자.</p><pre tabindex=0><code>recent_notifications:{{username}} = [{{json string}}, {{json stirng}}]

예를 들어 유저가 umi0410이라면 
아래와 같이 Redis에 해당 유저의 최근 알림 내역 정보를 저장할 수 있을 것이다.

recent_notifications:umi0410 = [
    &#34;{\&#34;id\&#34;: 1, \&#34;title\&#34;: \&#34;1번 알림입니다.\&#34;}&#34;,
    &#34;{\&#34;id\&#34;: 2, \&#34;title\&#34;: \&#34;2번 알림입니다.\&#34;}&#34;
]
</code></pre><p>위와 같이 데이터를 저장하면 읽을 때에도 특정 유저의 최근 알림 정보를 읽어올 수 있을텐데, 이때 앞서 언급했듯 Key만을 바탕으로 데이터를 조회하게 된다.</p><p>RDB의 경우 주로 의미 없는 Auto Increment ID를 PK이자 Clustered Index로 설정하기 때문에 Write 시에 Auto Increment ID를 바탕으로 디스크에 데이터가 연속된 위치에 저장되도록 하는 편이다. RDB는 PK가 아니라도 다양한 조건으로 값을 검색할 수 있기 때문에 PK는 성능을 고려해 의미 없는 Auto Increment ID를 넣는 것이다.</p><p>반면 Key-Value Database는 Key를 바탕으로 밖에 데이터를 조회할 수가 없기 때문에 Key (RDB의 PK와 유사하게 ID의 역할을 한다고 볼 수 있음)에 의미가 담겨야한다.</p><ul><li>🔵 Key가 <code>recent_notifications:umi0410</code> 처럼 조회 목적에 부합하는 정보를 포함하는 경우 → umi0410 유저에 대한 데이터가 저장되는 key 값을 알 수 있기 때문에 직접 Key 값을 찍어서 데이터를 조회할 수 있음</li><li>❌ Key가 <code>recent_notifications:1</code> 처럼 의미 없는 숫자값인 경우 → umi0410 유저에 대한 데이터를 찾으려면 Full scan을 해야할 수 있음.</li></ul><h2 id=key-value-database는-언제-사용하면-좋을까>Key-Value database는 언제 사용하면 좋을까?</h2><p>책에 나온 Key-Value database 사용 예시를 다시 보니 별로 마음에 안 들어서 내 생각대로 적어보려한다. 기본적으로 Key-Value database는 Key만으로 조회 요구사항을 만족할 수 있어야한다.</p><p>Redis와 같은 In-memory 데이터베이스의 경우에는 낮은 레이턴시가 중요하다거나 수명이 짧은 데이터에 주로 사용한다. 많이 봐왔던 케이스는 <strong>캐시나 장바구니 정보, 세션 정보 등이 있는 것 같다.</strong></p><p>유저가 처음 앱에 접속할 때 필요할 만한 알림 개수나 피드 정보등을 캐시해두면 좀 더 빨리 유저에게 정보를 전달할 수 있을 것이다.</p><p>장바구니나 세션 정보 같은 것들은 영구적으로 필요한 데이터가 아니면서 정합성이 엄청 중요하다거나 관계가 복잡한 데이터가 아니기 때문에 간단하게 Key-Value DB를 이용하면 좋을 것 같다.</p><p>“Redis 장바구니”나 “Redis shopping cart”로 구글링하면 자료가 꽤 나와서 나중에 시간 되면 좀 더 찾아보고싶다.</p><h1 id=document-database>Document database</h1><p>Document DB는 Key-Value와 꽤나 유사하지만 Value의 형태가 단순한 값이라기보단 JSON이나 YAML, XML 같은 Semi structured(반정형) 형태를 띄는 데이터베이스를 말한다.</p><p>문서는 Key-Value 쌍의 집합이라고 볼 수 있다. 따라서 데이터 형태가 단순하면 Key-Value DB를, 그보다 좀 더 복잡하면 Document DB를 사용하는 편이라고 한다. 여기에 추가적으로 클러스터가 훨씬 커지고, 한 Key에 관련된 정보가 방대해지면 Columnar DB를 도입하게 되는 것 같다.</p><p>Document DB는 관계형 데이터베이스와도 유사한 개념을 갖기도 한다.</p><ul><li>관계형 데이터베이스에서는 Row, 문서 데이터베이스에서는 문서가 존재</li><li>관계형 데이터베이스에서는 Row의 집합인 테이블, Document DB에서는 문서의 집합인 컬렉션이 존재</li><li>단, 관계형 데이터베이스는 같은 테이블 내의 Row들이 모두 동일한 형태를 갖도록 스키마를 강제한다.</li><li>문서 데이터베이스는 같은 컬렉션 내의 문서들이 얼마든지 다른 형태를 가질 수 있다!</li></ul><p>Document DB는 Unstructured data가 아닌 그나마 조금은 구조가 존재하는 Semi structured data를 저장하기 때문에 좀 더 다양한 질의가 가능하다. 예를 들어 Key가 아닌 속성을 바탕으로도 질의를 할 수 있고, 인덱스를 걸 수도 있다.</p><p>단 RDB와 마찬가지로 인덱스 설정을 너무 적게 하면 읽기 성능이 나빠질 수 있고, 인덱스 설정을 너무 많이 하면 쓰기 성능이 나빠질 수 있다.</p><p>BI(Business Intelligence)나 일반적인 웹 서비스는 Write 보다 Read가 훨씬 많다. 반면 로그성 데이터들은 Write가 Read보다 훨씬 많다.</p><p>만약 Read와 Write가 둘 다 많으면서도 짧은 Latency가 중요하다면 Write용으로는 단순 적재형 데이터베이스와 Read 용으로는 수많은 인덱스를 지원하기 용이한 데이터 웨어하우스 등을 이용하는 것이 좋다. 즉 어느 한 가지 DB만을 선택할 것이 아니라 각 DB를 각 필요한 상황에 적용할 수도 있다는 것이다. 주로 쓰기 작업에 최적화된 DB의 내용이 읽기 작업에 최적화된 DB로 전달되도록 구축한 뒤 쓰기 작업과 읽기 작업을 각각 다른 DB를 이용하는 형태가 많이 사용된다고 한다.</p><h2 id=문서-db에서-관계-나타내기>문서 DB에서 관계 나타내기</h2><p>RDB는 관계를 주로 테이블 간의 참조를 통해 나타낸다. 관계의 종류에는 1 대 1, 1 대 다, 다 대 다가 있다.</p><ul><li>1 대 1과 1 대 N 관계<ul><li>1에서 완전히 상대 1이나 상대 N 을 완전히 서브 문서 형태로 정의를 할 수 있다.</li></ul></li><li>M 대 N 관계<ul><li>한 쪽이 한 쪽을 완전히 포함할 수는 없어 결국엔 두 개의 컬렉션이 필요하다.</li><li>자신과 관련된 상대방 정보는 각자가 저장하기 때문에 양쪽에 데이터가 최신화되고 참조 무결성을 보장하도록 애플리케이션 레벨에서 잘 처리해야한다.</li><li>책에는 자신과 관련된 상대 문서들의 ID를 리스트로 관리해 참조하도록 나와있는데 이 경우에도 중첩 문서의 형태로 나타낼 수는 있을 것이라 생각한다.</li></ul></li></ul><p>간단히 Key-Value DB, Document DB에 대해 알아봤다. 이제는 NoSQL에서 노드의 역할은 어떤 것들이 있을지, 각 노드들은 어떤 데이터들을 어떤 로직에 의해 담당하게 되는지 정리해보려한다.</p><h2 id=문서-db는-언제-사용하면-좋을까>문서 DB는 언제 사용하면 좋을까?</h2><ul><li>데이터 형태가 Key-Value에 저장할 정도로 간단하지는 않은 경우</li><li>Key 만으로 조회 요구사항을 충족할 수 없는 경우</li><li>ACID 트랜잭션까지는 필요하지 않은 경우</li><li>데이터의 형태가 정형화되지 않고 조금씩은 달라서 Schema를 준수하기 힘든 경우</li><li>관계형 데이터베이스로는 요청을 처리하는 한계가 있어 수평 Scale이 필요할 정도인 경우</li></ul><p>요청이 쏟아지는 게 아니라면 사실 관계형 데이터베이스로 많은 상황들을 해결할 수 있고 그 경우 아직은 나는 관계형 데이터베이스를 사용하는 것을 선호한다. 아무래도 역사가 깊어서 레퍼런스도 많고 편리한 ORM 도구들도 많기 때문이다.</p><p>하지만 <strong>고정된 스키마를 준수하기 힘들거나 수평 scale이 필요한 경우에는 문서 DB를 사용하는 것이 더 적절하다</strong>. 예를 들면 게시판, 댓글, 채팅 메시지등이 될 수 있을 것 같다.</p><p>반면 주문이나 결제 내역, 재고 상황 같은 데이터들은 ACID 트랜잭션이 필요할 수 있어 관계형 데이터베이스를 사용하는 게 좋을 것 같다.</p><h1 id=rdb에서-많이-사용되는-마스터-슬레이브read-replica-구조>RDB에서 많이 사용되는 마스터-슬레이브(Read Replica) 구조</h1><ul><li>쓰기 권한이 있는 Master node는 여전히 한 대, Master node를 복제해 Read 요청만 처리하는 Replica는 여러 대 둘 수 있는 구조</li><li>여러 서버를 하나의 서버처럼 사용할 수 있는 형태인 클러스터 형태 치고는 그나마 단순하다.</li><li>쓰기에 비해 읽기 요청이 월등히 많은 경우 사용할 수 있다!</li><li>노드 간 통신이 많이 필요 없고 주로 복제를 위해 마스터 ↔ 슬레이브간의 통신만 하면 되는 경우가 많다.<ul><li>Columnar DB의 경우 다수의 마스터가 존재할 수 있고, 이 경우 상태 체크를 위해 다수의 마스터 노드 간에 통신이 필요하고, 이를 위해 “가십 프로토콜” 같은 프로토콜이 존재하기도 한다.</li></ul></li></ul><p>나는 AWS를 주로 사용해온터라 RDS를 다룰 때에는 Read replica 얘기가 빠짐 없이 등장해서 친숙했다. RDB는 원래 수평적 Scale이 힘든 편이다. 엄격히도 일관성을 중요시하다보니 분산 환경을 지원하지 않는 경우가 많은 것 같고(확실하진 않음 ㅎㅎ) 지원한다해도 노드 수가 증가함에 따라 성능도 선형적으로 증가하기는 힘들다. 그래도 RDB에서의 수평적 Scale에 대한 니즈도 많이 존재하다보니 요즘은 AWS에서도 Aurora에 Multi master 기능을 붙이거나 RDS에도 최대 15개 갈이의 Read Replica를 지원하기도 한다.</p><p>하지만 아무래도 RDB의 엄격한 일관성이 갖는 한계를 완전히 떨쳐낼 수는 없기 때문일지 손가락 발가락 합쳐서 셀 수 있는 개수 정도 까지만 수평 Scale이 가능한 것 같다.</p><p>그 개수를 NoSQL 중 하나인 Redis와 비교해보자. Redis의 경우는 1000개의 마스터 노드까지도 선형적으로 성능이 증가한다고 한다. 선형적인 증가를 조건으로 했을 때 최대 1000개의 마스터인 것이지 약 16,000여개의 마스터까지도 늘릴 수는 있긴하다. 게다가 각 마스터 노드에 대한 슬레이브까지 구성할 수 있으니 얼마나 확장성에서 차이가 나는지 어느 정도 실감할 수 있다.</p><h1 id=파티셔닝-partitioning>파티셔닝 (Partitioning)</h1><p>파티셔닝이란 무언가를 분리하는 작업을 말하는데 데이터베이스에서는 주로 데이터를 분리해서 저장하는 경우를 말한다.</p><ul><li>수직 파티셔닝 - 한 테이블을 여러 가상의 테이블로 분리해서 저장하는 것</li><li>수평 파티셔닝 - partition key를 바탕으로 분산하여 그에 해당하는 값을 저장하는 것</li></ul><p><figure style=flex-grow:179;flex-basis:430px><a href=/blog/computer-science/book-review-nosql-introduction-2/partitioning.png data-size=1793x1000><img src=/blog/computer-science/book-review-nosql-introduction-2/partitioning.png srcset="/blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_480x0_resize_box_3.png 480w, /blog/computer-science/book-review-nosql-introduction-2/partitioning_huae423b6d1a3ea56410a819f008ee156e_828970_1024x0_resize_box_3.png 1024w" width=1793 height=1000 loading=lazy alt="파티셔닝 예시"></a><figcaption>파티셔닝 예시</figcaption></figure></p><p>RDB에서는 주로 수직 파티셔닝만을 지원하고, NoSQL에서는 굳이 수직 파티셔닝을 이용하기보단 수평 파티셔닝을 이용하는 경우가 많다. (왜 NoSQL에서는 수평 파티셔닝을 잘 사용하지 않는지는 잘 모르겠다.)</p><p>RDB에서는 수직 파티셔닝을 통해 자주 함께 접근하는 컬럼들은은 SSD 파티션에 저장하고, 잘 접근하지 않는 컬럼들은 HDD 파티션에 저장하는 것 같다.</p><p>NoSQL에서는 주로 Partition key로 데이터가 저장될 노드가 결정되고 그 노드에 데이터를 저장한다.</p><h2 id=샤딩-sharding>샤딩 (Sharding)</h2><p>그중에서도 수평 파티셔닝은 샤딩이라는 또 다른 이름을 갖고 있다.</p><p><figure style=flex-grow:179;flex-basis:431px><a href=/blog/computer-science/book-review-nosql-introduction-2/shard.png data-size=421x234><img src=/blog/computer-science/book-review-nosql-introduction-2/shard.png srcset="/blog/computer-science/book-review-nosql-introduction-2/shard_hu1ff96d9a5545f8f306191c429eca38fc_36432_480x0_resize_box_3.png 480w, /blog/computer-science/book-review-nosql-introduction-2/shard_hu1ff96d9a5545f8f306191c429eca38fc_36432_1024x0_resize_box_3.png 1024w" width=421 height=234 loading=lazy alt="AWS ElasticCache의 Shard. 출처: https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Shards.html"></a><figcaption>AWS ElasticCache의 Shard. 출처: <a class=link href=https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Shards.html target=_blank rel=noopener>https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Shards.html</a></figcaption></figure></p><p>파티션 키(샤드 키)를 통해 그 키에 대한 데이터를 담당하는 노드 그룹을 샤드라고 하고, 한 샤드는 Primary 노드만 존재할 수도 있고 Read replica들도 존재할 수도 있다.</p><p>그럼 파티션 키라는 놈을 바탕으로 데이터가 어디에 저장될 지를 구체적으로 어떻게 결정하는 걸까?</p><ul><li><code>Range Partitioning</code> - 파티션 키의 구간에 따라 어떤 노드가 담당할 지를 미리 선언해놓고, 이를 참조하여 샤드를 정한다.</li><li><code>Hash Partitioning</code> - 파티션 키를 인자로 해싱 함수를 수행해 얻어지는 결과값을 샤드로 정한다.</li></ul><p>주로 많이 사용되는 접근법은 Range 기반과 Hash 기반 두 가지이다.</p><h2 id=range-partitioning>Range Partitioning</h2><p>Range partitioning은 아래와 같이 미리 파티션 키의 구간에 따라 어떤 노드가 담당할지를 미리 선언해야한다. 샤드가 4개 존재한다고 하겠다.</p><ul><li><code>id: 1</code> ~ <code>id: 1000</code>은 1번 샤드가 담당</li><li><code>id: 1001</code> ~ <code>id: 2000</code>은 2번 샤드가 담당</li><li><code>id: 2001</code> ~ <code>id: 3000</code>은 3번 샤드가 담당</li><li><code>id: 3001</code> ~ <code>id: 4000</code>은 4번 샤드가 담당</li></ul><p>아주 <strong>직관적이고 간단하다</strong>는 장점이 있다.</p><p>하지만 <strong>단점도 존재</strong>한다. <strong>예상하지 못한 파티션 키(4000 &lt; id)인 id: 4001인 데이터</strong>가 등장하게 되면 어떻게 될까? 올바르게 데이터를 저장하지 못할 수 있다.</p><p>또한 1번, 2번 샤드는 비교적 오래된 유저에 대한 데이터이고 3, 4번 샤드는 최근 유입 유저에 대한 데이터라 각 샤드들에 대한 요청의 수가 상이하다면 어떻게 될까? <strong>올바르게 요청이 분산되지 못하고 특정 샤드들에게만 집중될 수 있다</strong>는 문제가 있다.</p><p>또한 결국은 어딘가에 이 Range 할당 정보를 저장하고 그것을 조회해야한다. 공통으로 필요한 데이터가 어느 한 곳에 저장되어야한다는 부분에서 요청이 증가하고 샤드도 확장되는 상황에서 이런 Range 할당 정보를 제공하는 측이 병목이 될 수도 있다.</p><h2 id=hash-partitioning>Hash Partitioning</h2><p>Hash partitioning은 Range partitioning과 달리 <strong>어떤 샤드가 어떤 파티션 키를 담당하는지에 대한 매핑 테이블이 존재하지 않는다.</strong> 요청자측에서 <strong>Hash 함수</strong>를 수행한 결과값으로 자신이 요청해야하는 노드를 유추할 수 있다.</p><p>예를 들어 Range partitioning과 같이 샤드가 4개 존재한다고 해보자</p><ul><li><code>id % 4 == 1</code> 이면 1번 샤드가 담당</li><li><code>id % 4 == 2</code> 이면 2번 샤드가 담당</li><li><code>id % 4 == 3</code> 이면 3번 샤드가 담당</li><li><code>id % 4 == 0</code> 이면 4번 샤드가 담당</li></ul><p>클라이언트에 필요한 정보는 샤드 개수 뿐이다. id=4001인 데이터가 등장해도 4001 % 4는 1이므로 1번 샤드가 담당하면 된다.</p><p>지금 예시에서는 Partition key가 id로 numeric한 값을 갖기 때문에 hash 함수를 거치지 않고 모듈러 연산만으로도 원활히 동작하는 것 같지만 실제로는 non-numeric한 값들에 대해서도 지원하고 골고루 데이터가 분산될 수 있도록 하기 위해 해싱 함수들을 사용한다.</p><p>단 Hashing partitioning에도 단점이 존재하는데 바로 수평 Scale시에 각 샤드가 담당하는 데이터가 상이해질 수 있다. 예를 들면 노드가 2대 → 4대로 증가하는 경우를 예로 들어보겠다.</p><ul><li>기존 (노드 2대)<ul><li><code>id = 1</code> → 1번 노드</li><li><code>id = 2</code> → 2번 노드</li><li><code>id = 3</code> → 1번 노드</li><li><code>id = 4</code> → 2번 노드</li></ul></li><li>수평 Scale 후 (노드 4대)<ul><li><code>id = 1</code> → 1번 노드</li><li><code>id = 2</code> → 2번 노드</li><li><code>id = 3</code> → <del>1번 노드</del> 3번 노드</li><li><code>id = 4</code> → <del>2번 노드</del> 4번 노드</li></ul></li></ul><p>위와 같이 데이터를 담당하는 샤드들이 많이 변경되어 rebalance가 필요하다는 어려움이 존재한다. 게다가 이 어려움은 Scale out 때 뿐만 아니라 Scale in 시에도 존재하기도 한다.</p><p>이런 rebalance 과정을 좀 더 최적화하기 위해 consistent hashing이라는 개념이 존재하고 이에 대한 구현체로 virtual node들을 두는 ketama consistent hashing도 존재한다. 이에 대해서는 책에 깊게 등장하진 않고 구글링으로 많은 자료를 찾아볼 수 있기에 이번 글에서는 생략하도록 하겠다.</p><h1 id=마치며>마치며</h1><p>Key-Value 데이터베이스와 Document 데이터베이스의 특징에 대해 적어봤다.</p><p>책 내용을 잊어버리기 전에 한 번 정리해보면서 복습하려했었는데 살짝 까먹어가던 내용이나 대충 읽고 넘어간 부분에 대해서도 점검해볼 수 있었던 것 같다.</p><p>( <strong>책 내용 뿐만 아니라 나중에 복습할 용도로 제가 기존에 알고 있던 내용이나 주관적인 의견들도 조금씩 적어놨습니다. 잘못된 내용이라 생각되는 부분이 있으시면 알려주시면 감사하겠습니다!</strong> )</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>관련 글</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/blog/computer-science/book-review-nosql-introduction-3/><div class=article-image><img src=/blog/computer-science/book-review-nosql-introduction-3/cassandra-modeling.8740760486ad3f80a81748e94068834b_hu4c562377df99e1314a765d985ca6b3ef_61429_250x150_fill_box_smart1_3.png width=250 height=150 loading=lazy data-key data-hash="md5-h0B2BIatP4CoF0jpQGiDSw=="></div><div class=article-details><h2 class=article-title>(도서) "NoSQL 철저 입문" - Column-Family DB, Graph DB</h2></div></a></article><article class=has-image><a href=/blog/computer-science/book-review-nosql-introduction-1/><div class=article-image><img src=/blog/computer-science/book-review-nosql-introduction-1/cover.dba34b1fce6fe607868b6818dcea6cfa_hue5cdea400e5bd3f90bce9c064a33eba6_152854_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy data-key data-hash="md5-26NLH85v5geGi2gY3Ops+g=="></div><div class=article-details><h2 class=article-title>(도서) "NoSQL 철저 입문" 후기 및 NoSQL의 공통적 특징</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//umi0410.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2022 Jinsu Playground</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.4.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#key-value-database는-언제-사용하면-좋을까>Key-Value database는 언제 사용하면 좋을까?</a></li></ol><ol><li><a href=#문서-db에서-관계-나타내기>문서 DB에서 관계 나타내기</a></li><li><a href=#문서-db는-언제-사용하면-좋을까>문서 DB는 언제 사용하면 좋을까?</a></li></ol><ol><li><a href=#샤딩-sharding>샤딩 (Sharding)</a></li><li><a href=#range-partitioning>Range Partitioning</a></li><li><a href=#hash-partitioning>Hash Partitioning</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>